<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[天镶的博客]]></title>
  <subtitle><![CDATA[尘世间一个迷途的小码农]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://lingyu.wang//"/>
  <updated>2016-02-17T14:12:59.000Z</updated>
  <id>http://lingyu.wang//</id>
  
  <author>
    <name><![CDATA[天镶]]></name>
    <email><![CDATA[lingyucoder@gmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[2015年总结]]></title>
    <link href="http://lingyu.wang/2016/02/16/2015/"/>
    <id>http://lingyu.wang/2016/02/16/2015/</id>
    <published>2016-02-15T16:00:00.000Z</published>
    <updated>2016-02-17T14:12:59.000Z</updated>
    <content type="html"><![CDATA[<p>年终总结结果到这个时间才写，其实也是无奈。本来计划过年写的，没想到Steam竟然开了个农历春节特惠，然后就被各种游戏打了，<strong>辣鸡平台，敛我钱财，颓我精神，耗我青春，害我单身</strong></p>
<a id="more"></a>
<blockquote>
<p>以下全都是个人看法，如果有不认同的地方，请大吼一声“傻逼写的啥”然后关闭页面</p>
</blockquote>
<h2 id="转职">转职</h2><p>本命年终于快过去了，不知道是不是因为没有穿红裤衩，这一年有很多不顺心的事情，不过也有很多好事。这一年最重要的事情就是顺利从一只学生狗转职为一只社畜。四月份毕业之后以前端工程师的职位入职天猫，到现在也差不多工作一年了。这里写一下干这行以来对于“前端”这个行业的看法和感悟。</p>
<p>前端工程师在校园里是一个复杂度和地位都被严重低估的职位。老师们对发展迅猛的前端技术不够了解，更是有不少“师兄师姐”在介绍自己找工作经验时“xx天速成就找到一份前端工作”、“公司招聘前端也不问会什么，就问你肯不肯踏实干这行，肯干进去再教你”。当然学校里的项目里也会有页面，但由于老师和学生对前端各种技术的陌生，大多数都是使用jQuery堆积代码完成功能了事。在大家眼里，写页面没啥技术含量。</p>
<p>前端的很多基础知识，都无法在学校学到。学校老师交给学生的大多都是基础知识，比如算法、数据结构、编译原理、操作系统、计算机网络这些，而针对于特定领域就很少涉及了。见过学校开设C、C++、Java、PHP等语言的课程，却从来没有看到过开设JavaScript、CSS、HTML的课程。网页设计的选修课倒是有（我报了，很遗憾整个教室只有20人不到），但这里所谓的网页设计并不是前端那一套技术栈，而是Dreamweaver使用入门。前端技术栈在校园里没有普及。</p>
<p>就这样产生了一个很有意思的现象：大堆公司喊缺前端，而学生们并不知道前端是什么，怎么去学习前端知识（最近两年稍微好点了），他们更多的是去学Java、C++，走着师兄师姐们走过的道路。有幸现在已经有百度这种大公司注意到了这点，到高校里开了不少前端知识讲座，还在GitHub上搞了培训项目。</p>
<p>希望各个大公司的前端部门能够更多的走进校园，给对前端感兴趣的小朋友们一点指导。</p>
<h2 id="React">React</h2><p>去年上半年4月份入职打杂了一段时间之后，就开始学习React并且进行了一些实战演练：</p>
<ol>
<li>产出一篇文章<a href="http://lingyu.wang/#/post/2015/5/15/react-and-webpack">轻松入门React和Webpack</a>，意外的很受好评，<a href="https://segmentfault.com/a/1190000002767365" target="_blank" rel="external">segmentfault</a>上超过了200的收藏，<a href="https://github.com/tmallfe/tmallfe.github.io/issues/23" target="_blank" rel="external">tmall的github博客</a>上也有不少评论。可惜现在文章中已经有很多不适用了，babel大版本到6发生了不少变化，本地调试也改成中间件了</li>
<li>把自己的博客<a href="http://lingyu.wang">lingyu.wang</a>改成了全React实现，用react-router做了个单页面应用，底层依然基于hexo，自己给hexo写了个<a href="https://github.com/LingyuCoder/hexo-generator-async" target="_blank" rel="external">generate插件</a>把所有数据生成json而不直接生成页面，为了练手已经丧心病狂了，SEO什么的完全不在乎</li>
<li>写了一些脚手架和组件，乱七八糟参见<a href="https://github.com/LingyuCoder/toybox" target="_blank" rel="external">玩具箱</a></li>
</ol>
<p>由于负责天猫最复杂的前端应用之一的开发和维护，有不少老代码，也由于迁移成本太大没有办法在Java层上插入Node.js中间层，各种模块之间各种耦合，中间也写了篇<a href="http://lingyu.wang/#/post/2015/8/30/chonggou">用React做重构时的一些思考</a>。当时项目里存在以下几种耦合：</p>
<ol>
<li>最蛋疼的就是压根就没有模块化，所有代码都在一个文件里，2k+行的jQuery那种。最老式的写法，也是在学校项目里看到最多的方式，选择器拿到DOM然后操作绑事件，大多多年前的代码或者是后端兼职写的。基本上没有可维护性。解决这种基本上就靠推倒重写了，考虑投入产出比看懂它的成本还不如重新写一个来得快</li>
<li>稍微好一点的是增加了模块化，但模块内部和之前思路没什么区别，只是把上面那种代码分开多个文件放了。不同的模块在模块内部操作相同的HTML，一旦其中一个模块改变了HTML结构，其他模块直接就bug了…</li>
<li>再好一点增加了前端模板引擎，各个模块都在内部使用模板引擎渲染自己的HTML，模块初始化传入一个容器，只要容器不冲突，模块之间就不会基于HTML耦合。模块会暴露一些接口，通过模块管理器获取实例相互之间直接相互调用，这样依旧是强依赖，两个模块互相依赖，一旦其中一个换了，接口变了，另外一个模块也需要改变自己的代码。</li>
<li>模块内部完全黑盒，只要一个容器，里面的内容由模块自己控制。模块有数据的入口和出口，入口就是一些由父模块或页面传入的配置，出口则是一些由父模块或页面传入模块回调函数，回调函数里面附带传出的数据，而HTML相互之间无法互相修改，改了就报错。没错这就是React</li>
</ol>
<p>最后重构的方案定下来是React+AMD+Gulp（你没有看错，没有打包，没有webpack），之所以不打包主要是有老代码，组件页都没发布到npm上，而且由于阿里的CDN支持combo，所以也就不做打包了，至于使用React做重构，主要是由于以下几个原因：</p>
<ol>
<li>使用React实现的模块和组件完全黑盒，Web Component理念，标签使用方便快捷。不会引入新的维护成本</li>
<li>组件容易抽离，形成沉淀。我曾经把一部分新业务使用React实现，其中的不少组件稍加完善就沉淀出一些基础组件，没有剥离成本</li>
<li>模块相互之间不会污染，没办法直接修改其他模块的DOM，改了就报错，然后QA就提着刀杀过来了</li>
<li>商家应用，允许全异步，富交互功能型页面，性能不太烂都能接受</li>
</ol>
<p>目前新业务已经完全基于React开发，组件库也基本上沉淀出来了，而老业务也在通过一次次需求像React迁移</p>
<h3 id="模块的实现和通信">模块的实现和通信</h3><p>个人比较倾向于完全区分模块和组件这两个概念。组件是完全没有业务逻辑的功能单元，比如下拉框啊、日期选择啊这种，组件只专注自身的功能。组件可能会有嵌套，但当发生了嵌套时，对外就是一个组件，父组件内部的子组件对外将完全不可见，它的行为也将完全由父组件控制。组件是复用的单元，应当更多的形成沉淀。而模块则包含业务逻辑，同时模块还承载了一个比较重要的功能：和其他模块通信。</p>
<p>所以大体上一个应用就是：应用被划分为多个业务模块，这些模块逻辑上是扁平的，他们采用统一的通信机制进行通信，一个模块上的数据发生变更时，会通知一个全局的通信中心，采用pub-sub机制将数据递交给其他模块，其他模块拿到数据后影响自己的渲染。模块内部使用了很多的组件，但模块内部所有渲染使用的数据都由模块直接进行管控，树形传递给各个组件。可以这么想，模块内部类似Redux实例，而页面上有多个Redux实例，它们再通过一个统一的pub-sub中心进行通信。为什么不整个应用直接做一个Redux实例呢？主要是因为要考虑到跨BU合作和新老多种技术兼容。模块内部想怎么玩怎么玩，可以是React实现，可以使Vue实现，可以是原生js实现。模块作为一个通信单元只要符合统一pub-sub通信接口即可。</p>
<p>这套理念也确实实现并且落地到了不少页面中，但这样玩显然还不够过瘾。React终究是前端在玩，前端写React组件、模块和页面很爽，但是数量大了一样要加班一样爽不起来。这里就在考虑有没有可能降低门槛，把事情交给别人来做，比如后端。首先组件肯定是前端来写了，没多少后端能写好前端组件的，如果能写好，他就不是后端而是全栈了，这种人就应该果断拉过来干前端堵缺口。那么有没有可能把模块和页面交给他们来写，而前端只提供一些组件呢？</p>
<p>让后端写，最重要的一点就是给模板赋能，毕竟后端只能接触到模板。这么一想，这不特么就是React和MVVM相结合么，把React的Virtual DOM或者说JSX标签和MVVM的DOM模板一样写到HTML上，多么Web Component化啊。这里说一下为什么不直接用MVVM比如Vue，而是用React。MVVM确实对后端开发工程师很友好，但这些组件是我们平常开发前端应用（前端部分前端自己负责的复杂业务）时沉淀下来的，这么一大批组件让我们再去重写一份MVVM的太蛋疼了，后期维护两份也比较吃力。就这样开始尝试，经过一段时间调研后，发现<a href="https://github.com/wix/react-templates" target="_blank" rel="external">react-templates</a>，可以把模板字符串转化为<code>React.createElement</code>，当时用browserify给它打了一个包，尼玛压缩后好像有500K+（未gzip），它是针对Node.js的。于是乎把它整个代码大体上进行了重写，移除了lodash，自己重写了使用的一些工具方法，然后又重写了模板解析部分，采用浏览器的XML解析器，又移除了esprima等语法校验，然后又加了一堆定制化，最后压缩后20K左右（未gzip），终于可以在页面上用了…最后大体上就实现了一套这样的方案：</p>
<ul>
<li>一堆日常沉淀的React组件</li>
<li>一个全局的pub-sub通信工具负责模块的通信</li>
<li>一个React实现的Module负责充当模块的角色</li>
</ul>
<p>Module内部使用React Templates字符串模板编译成Virtual DOM的函数来进行渲染，可以通过一些“控制指令”来控制渲染结果，组件上面可以通过一些“通信指令”来递交组件的数据给Module这个模块。而Module模块数据发生变更后会触发整个模块重绘，数据又会重新传递下来给组件并变更组件的渲染结果。</p>
<p>Module外部则是通过全局的pub-sub通信工具来负责模块通信，Module负责与这个通信工具进行直接交互来进行数据通信。通信建立桥接的方式也是在Module上定义一些“通信指令”</p>
<p>最后，整个系统都采用React Templates来实现，整个页面实现和通信全部写在模板上，页面上只有一堆组件（可以在模板里动态require，模板会在编译期提取然后拉取完成了才进行初始化）。没有任何业务js逻辑存在。</p>
<p>这样实现了好几个页面我已经成功上线跑了几个月了，还有几个正在实现中，看上去很美好。但后来还是发现了一些问题：<strong>模块通信过程太复杂</strong>，一个完整的数据流转过程通过指令很难很直观的展现，一个看起来很简单的交互中间可能会经过4-5步数据流转，甚至包括一些alert、confirm等等，想让后端写不太可能，连其他前端都看不太懂数据如何流转。这一块还有太多可以优化的地方。</p>
<h2 id="流程自动化">流程自动化</h2><p>去年下半年我参与了部门统一使用的前端流程自动化工具的维护及改造，花了不少时间在前端流程自动化上。前端经过这么多年的发展，页面上承载的交互、功能、逻辑不断增加，项目逐渐变得庞大，维护和开发成本也随之增加，但依然招不到人。<strong>这里顺带打个广告，如果想来天猫前端的请发邮件至lingyucoder@gmail.com</strong>。流程自动化也就愈发重要。最理想的状况就是，只要是机械能够完成的工作，人就不要参与了。用一些脚本代替简单重复的劳动，这样我们也就可以少加点班了。</p>
<h3 id="Node-js">Node.js</h3><p>Node.js给前端开发流程自动化带来了福音。从目前部门前端开发流程来看，主要就是以下几个步骤，括号里是对应的开源工具：</p>
<ol>
<li>创建项目（Yeoman）</li>
<li>构建以及监听文件变化自动构建（Gulp、Webpack、Grunt，Grunt估计现在用的很少了）</li>
<li>本地调试，资源代理（Koa、Express+各种定制的中间件）</li>
<li>自动化测试、代码覆盖率测试（mocha、istanbul、should/chai/expect、phntomjs、karma）</li>
<li>文档自动化生成（自己基于AST提取，或者直接用jsdoc之类的工具）</li>
<li>自动化校验、发布（一些脚本）</li>
</ol>
<p>这里主要聊聊构建、本地调试和自动化测试</p>
<h3 id="构建">构建</h3><p>现在的构建过程已经不再像以前那样压缩一下就简单，构建过程中往往会拿代码生成语法树然后做各种操作：</p>
<ol>
<li>Babel爽爽写ES6甚至ES7</li>
<li>将代码中的注释转化为监控打点（istanbul我记得就是基于语法树给每个语法分支包一层打点层，汇总数据）</li>
<li>将代码中的注释提取生成文档（React组件自动生成props文档就是这种方式）</li>
<li>将commonjs规范的代码转化为各种各样的模块化解决方案（AMD、KMD、UMD等等）</li>
<li>提取模块间的依赖关系，梳理应用模块依赖关系，绘制模块依赖树</li>
<li>Webpack打包</li>
<li>各种语法检查（eslint，jshint），有时候还会有一些定制化的校验</li>
<li>…</li>
</ol>
<p>现在大家都比较中意webpack，依赖打包使得资源请求数大幅度减少（使用不支持combo的CDN服务的公司肯定很开心）。我个人还是对于webpack有一些顾虑，主要有两点</p>
<ol>
<li>不太赞同浏览器内使用的资源也发布到npm上。浏览器上和Node.js通用的代码可能也就不到5%（lodash啊，underscore啊，moment啊这种），在npm上找到一个模块还要确认到底哪个场景下可用。使用的即便是这些可以共用的库，也会有一个很蛋疼的问题：Node.js的模块往往大而全实现尽可能多的功能，而页面使用的模块则是尽可能小而美，资源加载量尽可能少。比如只用到时间格式化和反格式化就引入一整个moment（moment真特么大，我一般就格式化反格式化，喜欢用fecha），对于Node.js也许没什么压力，但对于页面就很蛋疼了。现在rollup试图解决这个问题，还是比较值得看好的</li>
<li>不同版本重复打包的问题。这个问题比较头疼。如果一个项目依赖了两个组件，而这两个组件引用了一个库的两个不同版本，这个库就会被打包两份，于是乎代码量就duang一下增大了。目前依旧没有看到比较好的方式来解决。虽然可以用peerDependencies对一些基础库（比如React这种）做一下处理，也只是缓解一些罢了。</li>
</ol>
<p>另外吐槽一句，webpack配置真繁琐啊，个人目前倾向的方案是使用webpack+gulp，webpack负责打包和构建，其他的工作依旧交给gulp，我喜欢stream（不是steam）</p>
<h3 id="本地调试">本地调试</h3><p>前端资源本地调试其实挺简单的，就是把线上使用的资源代理到本地资源。由于现在一般都会使用CDN来承载这些资源（如果你们公司不用CDN，请找你们老板拨点经费买个CDN服务吧），大致上也就是几个步骤：</p>
<ol>
<li>把CDN的域名通过host指向本地</li>
<li>在本地80（HTTP）或443（HTTPS）端口开启对应的代理服务，根据请求查找本地资源返回</li>
<li>如果涉及需要开启多个服务，将各个服务开在不同的端口后在80或443端口加个nginx层做转发</li>
</ol>
<p>目前部门里面用的是Koa+中间件实现了这里面所有的内容。Koa现在也2.0了，使用新版本的Promise的co，用起来还是很爽的</p>
<p>如果一旦涉及到本地模板的调试，就很蛋疼了，基本上是模拟数据，这里懒得扯了。</p>
<h3 id="自动化测试">自动化测试</h3><p>对于自动化测试这一块，在学生时代一直觉得测试麻烦，没啥收益。但实际上自动化测试对于开发效率提升很大。之前参与部门统一构建工具的改造，有任何修改就跑一遍测试用例和代码覆盖率，效率非常高，还非常容易形成沉淀，一旦有bug，就把bug会发生的场景也做成一个测试用例，方便后人接手。而且把代码接入像travis这样的持续集成平台后，代码质量更有保证了，任何一次push都会自动触发测试，即便是pull request里的代码也可以保证质量。现在写代码覆盖率低于90%就觉得各种不爽，一定要提到90%以上。</p>
<p>对于Node.js的模块，测试很方便，除了命令行工具可能需要加像sinon这样的模块来监听stdio以外，其他的基本上都能直接在代码中模拟环境。由于个人写Node.js代码喜欢拆分的很细，每个逻辑单元都用co、curry做包装，所以特别喜欢使用mocha+should，should 8.0+直接支持Promise，爽歪歪，</p>
<p>对于浏览器里跑的代码，测试和覆盖率就比较麻烦了，首先模拟环境比较蛋疼，大致上3种方案：</p>
<ol>
<li>构建一个测试页面，人肉直接到虚拟机上开各种浏览器跑测试页面（比如f2etest），这个问题就是不好持续化集成，人肉工作较多</li>
<li>使用phantomjs构建一个伪造的浏览器跑单元测试，大致上就是先用gulp-istanbul给代码打点，然后拿mocha-phantomjs跑包含测试用例的页面，最后通过hook拿到结果用istanbul生成可视化的覆盖率页面，蛋疼就是phantomjs毕竟是Qt的webkit，不是真实环境，phantomjs也是各种坑</li>
<li>通过karma调用本机各种浏览器进行测试，这个现在还没玩的很6，还在研究中。还是有不少问题没解决，毕竟用的mac，去哪儿找IE 8，囧，更别说移动端那么多机型</li>
</ol>
<p>对于测试个人一直坚持一个观点：<strong>基于投入产出比来做测试</strong>。由于维护测试用例也是一大笔开销（毕竟没有多少测试会专门帮前端写业务测试用例，而前端使用的流程自动化工具更是没有测试参与了）对于像基础组件啊，基础模型啊之类的不常变更且复用较多的部分，可以考虑去写测试用例来保证质量，但对于迭代较快的业务逻辑以及生存时间不长的活动页面之类的就别花时间写测试用例了，维护测试用例的时间大了去了，不如喝杯茶冷静下让QA他们去测吧。</p>
<h2 id="学习">学习</h2><p>这一年由于转职社畜各种忙的要死，导致没有多少时间静下心来看书了，文章也写得少了。于是更倾向于每天水一水<a href="https://github.com/LingyuCoder" target="_blank" rel="external">我的github</a>（中间一大段空白因为3DS到货了，鏖战怪物猎人4G，这游戏真特么好玩），写一些脚手架啊、组件啊、小工具啊啥的。之前觉得一些开源的logger不好用，就自己写了个<a href="https://github.com/LingyuCoder/linglog" target="_blank" rel="external">linglog</a>，之前负责一个业务变更比较多总是打tag发布，就写了个自动发布程序<a href="https://github.com/LingyuCoder/publishy" target="_blank" rel="external">publishy</a>，它会在发布前做一些校验防止我没有commit或者没有add之类的。还有像React组件自动化提取props做文档弄了个<a href="https://github.com/LingyuCoder/react-prop-table" target="_blank" rel="external">react-prop-table</a>，以及对应的配套的markdown内容段自动更新gulp插件<a href="https://github.com/LingyuCoder/gulp-insert-md" target="_blank" rel="external">gulp-insert-md</a>。对应还有一些less依赖关系解析啥的弄了<a href="https://github.com/LingyuCoder/less-tree" target="_blank" rel="external">less-tree</a>，然后有个需求要在模块更新时自动输出最新更新有哪些变动于是有了<a href="https://github.com/LingyuCoder/changelogy" target="_blank" rel="external">changelogy</a>，然后还有几个自己弄得带单元测试、代码覆盖率测试、travis持续集成、eslint等的脚手架：React组件脚手架<a href="https://github.com/LingyuCoder/generator-lingyu-react-component" target="_blank" rel="external">generator-lingyu-react-component</a>, Node模块脚手架<a href="https://github.com/LingyuCoder/generator-lingyu-node-modules" target="_blank" rel="external">generator-lingyu-node-modules</a>, gulp插件脚手架<a href="https://github.com/LingyuCoder/generator-lingyu-gulp-plugin" target="_blank" rel="external">generator-lingyu-gulp-plugin</a>, 命令行工具脚手架<a href="https://github.com/LingyuCoder/generator-lingyu-cli-modules" target="_blank" rel="external">generator-lingyu-cli-modules</a>。写这些玩意过程中学到了不少Node.js的姿势，虽然离一个真正的Node.js工程师差的太远</p>
<p>另外一点是入职后全面从sublime切到atom了，python苦手还是伤不起，咱用atom有插件需求找不到自己写一个，比如之前给xtemplate模板写了个atom语法高亮和snippet插件<a href="https://github.com/LingyuCoder/atom-language-xtpl" target="_blank" rel="external">atom-language-xtpl</a>，感觉比之前用sublime爽多了</p>
<p>还花了点钱买了<a href="https://www.renfei.org/snippets-lab/" target="_blank" rel="external">SnippetsLab</a>这个软件，用来放一些代码片段超好用，我在里面放了不少自己平常写的一些小的工具函数，比如clone啊，unique啊，param和unparam啊这种，需要的时候就搜一下复制出来，方便快捷</p>
<h2 id="生活">生活</h2><p>今年玩的游戏不多，因为3DS到货了，先说几个3DS游戏：</p>
<ol>
<li>怪物猎人，沉迷了一段时间，甚至一整天一整天的和各种龙做斗争。现在怪物猎人累计游戏时间应该有250小时了…</li>
<li>口袋妖怪X：硬着头皮啃英文，撸宠系统好棒，每天撸一撸自己的宠，看到他们开心的样子自己也开心。通了一周目就懒得啃英文了</li>
<li>牧场物语，在同事推荐下玩了，模拟经营农场，种菜、种果树、养各种动物卖钱…玩了几十个小时吧，玩不下去了…后面每天刷牛挤牛奶，撸鸡一天就结束了…没领悟到游戏的乐趣</li>
<li>路易吉鬼屋，超级玛丽里的弟弟被拉到鬼屋里探险的故事，乐趣就是看路易吉这个大写的怂货被各种鬼吓尿…解密游戏，其实挺好玩的</li>
<li>马里奥赛车：和跑跑道具赛差不多，玩道具赛，道具比较少，赛道也少，难度也低。</li>
<li>勇气默示录：回合制RPG，还在龟速通关中，画面很棒，3D的人物很Q，相当不错的游戏</li>
</ol>
<p>然后说一些PC的：</p>
<ol>
<li>侠客风云传：情怀！绝对的情怀！作为一个当年武林群侠传的狂热爱好者，侠客风云传我通关了至少6次，乞丐、东厂、盟主、霸图、天王各种都通了一遍。湘云还是一如既往的女神，希望徐大早日重制金庸群侠传</li>
<li>仙6：这个战斗系统特么什么鬼…没有玩下去的动力啊</li>
<li>堡垒（bastion）：很精致的游戏，画面唯美，歌曲好听，剧情不长但很好玩。</li>
<li>进化之地2（evoland2）：尼玛一个游戏能这么玩我算是长见识了，集DQ、塞尔达传说、超级玛丽、拳皇、双截龙、炸弹人、游戏王、洛克人、1943等等于一身的游戏也没谁了</li>
<li>阿玛拉王国：和老滚有点像，不过比老滚有打击感，重要的是有WOW那种装备系统。老滚的装备系统是个鬼…可惜没有老滚那么多mod，毕竟少女卷轴</li>
<li>饥荒：这游戏太特么难了，一到冬天就死…得找个大神带我</li>
</ol>
<p>春节剁手买了昆特牌3和龙腾世纪，有时间玩一玩。最后重申一句：<strong>辣鸡平台，敛我钱财，颓我精神，耗我青春，害我单身</strong></p>
<h2 id="感情">感情</h2><p>看他们的总结都有这个，于是我加上了</p>
<p><strong>光棍年数++</strong></p>
<h2 id="总结">总结</h2><p>前端发展太快，要学的太多。本来去年计划学React Native的，结果只写了个Demo…Electron也是只跑了个HelloWorld…Node.js的服务器也只是搭了个简单的…canvas也是只写了一些小Demo。希望新的一年技术不掉队，能够多学点这些之前想学没学的东西。另外希望能够沉淀出自己的组件库，以后快速搭建一个页面也方便一些</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>年终总结结果到这个时间才写，其实也是无奈。本来计划过年写的，没想到Steam竟然开了个农历春节特惠，然后就被各种游戏打了，<strong>辣鸡平台，敛我钱财，颓我精神，耗我青春，害我单身</strong></p>]]>
    
    </summary>
    
      <category term="学习" scheme="http://lingyu.wang/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="总结" scheme="http://lingyu.wang/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="生活" scheme="http://lingyu.wang/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="思考总结" scheme="http://lingyu.wang/categories/%E6%80%9D%E8%80%83%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[用React做重构时的一些思考]]></title>
    <link href="http://lingyu.wang/2015/08/30/chonggou/"/>
    <id>http://lingyu.wang/2015/08/30/chonggou/</id>
    <published>2015-08-29T16:00:00.000Z</published>
    <updated>2015-08-30T08:49:32.000Z</updated>
    <content type="html"><![CDATA[<p>好久没写东西了，主要是工作比以前学生时代忙多了，周末也是各种加班充电，沉淀的少了。最近一直在用React对手上的老业务做重构，这里写一下重构中的一些感悟和思考</p>
<a id="more"></a>
<h2 id="老业务和老代码">老业务和老代码</h2><h3 id="前台和后台">前台和后台</h3><p>入职之后刚开始接手的是前台展示业务，基本上是在已有的框架上写模块，前台业务尤其是活动期间光完成业务就累得半死。</p>
<p>后来随着一次业务调整，开始负责商家后台业务了，两边节奏和开发方式都完全不同。前台业务更新换代较快，没事就改个版啥的，后台就完全不同了：</p>
<ol>
<li>后台的业务偏重的是功能，与前台业务酷炫的交互不同，后台业务往往是数据的直观展示和CRUD操作</li>
<li>前台业务往往可以根据展示的区域划分为多个模块，模块较为独立，很少有模块之间的通信。而后台业务往往是多个子功能模块通过复杂的业务逻辑串联到一起形成完整的功能</li>
</ol>
<h3 id="一些感想">一些感想</h3><p>目前负责的应用应该是整个天猫最复杂的应用，里面都是一些老旧的代码，有很重的历史包袱。模块之间的划分不清晰，模块之间的耦合也比较严重，对DOM的交叉修改，不必要的依赖各种各样。进来后思考的最多的就是对这块老代码做重构。</p>
<p>当然老业务只是代码老，并不代表没有新需求，所以对于接手老代码的开发者来说，最重要的一点是：</p>
<blockquote>
<p>老坑没填的情况下，首先保证不会挖新坑，不要明知道之前的开发者使用了错误的开发方式，还不负责任的继续使用。历史问题会随着技术的发展和时间的推移而像滚雪球一样越滚越大，如果放任其滚下去很可能最后整个应用完全不可维护</p>
</blockquote>
<p>目前负责老业务并不是单纯的老到只需要维护就可以了，事实上还有大量的新需求不断加入当中，它们就是滚雪球时不断粘附到雪球上的雪</p>
<ul>
<li>对于与老代码之间耦合不是特别强烈的新需求，采用较为独立的模块化开发方式，以一种可插拔的形式嵌入到老业务中，保证插和拔的时候不会影响老业务正常运作</li>
<li>在老业务原有的代码上做更改，这是熟悉老业务代码的最佳方式，理清楚要修改的老业务代码逻辑，若涉及的模块和其他模块耦合程度较低，就将其抽离。如果耦合程度较高，就采用对现有架构尽可能小影响的开发方式开发</li>
<li>解耦的过程就像剥洋葱，剥离了最外面一层，里面一层就变成最外一层了，一层层剥到核心，整个解耦过程就完成了</li>
</ul>
<h2 id="老业务中的React">老业务中的React</h2><p>在整个解耦的过程中，采用React做解耦。目前比较流行的React开发方式是采用Common JS开发，模块直接通过npm管理，上线时采用webpack或browserify做打包。但受限于身上的历史包袱，不可能整页采用React实现，成本太大。目前整体页面依旧是普通JS，通过模块加载器管理着各个模块，其中一些模块是React实现的，利用browserify的babelify+babel-runtime做ES 6语法编译，保证即使ES 6语法编写的代码也能够正常跑在浏览器上，由于每个模块是独立的，因此这样会产生一些问题，后面会讲到</p>
<h3 id="React做模块">React做模块</h3><p>为什么要用 React 做解耦，主要是看中其封装理念，一个模块或组件，应当有：</p>
<ol>
<li>提供一些配置数据</li>
<li>模块自己内部逻辑用的数据</li>
<li>提供一些供交互的接口和事件</li>
</ol>
<h4 id="兼容JSX和原生JS调用">兼容JSX和原生JS调用</h4><p>1，2，3分别对应props、state和onXXX回调。对于老业务而言，如果外层不是React，而是模块加载器包裹的原生JS怎么办呢？其实React组件完全可以独立运行，毕竟有<code>React.render</code>，举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="string">'react'</span>, <span class="string">'event-mixin'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">React, EventMixin</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> defaultConfig = &#123;</span><br><span class="line">    value: <span class="string">''</span>,</span><br><span class="line">    onChange: noop</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">var</span> Component = React.createClass(&#123;</span><br><span class="line">    mixins: [EventMixin],</span><br><span class="line">    propTypes: &#123;&#125;,</span><br><span class="line">    getDefaultProps: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> defaultConfig;</span><br><span class="line">    &#125;,</span><br><span class="line">    getValue: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">    setValue: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  Component.init = <span class="function"><span class="keyword">function</span>(<span class="params">container, config</span>) </span>&#123;</span><br><span class="line">    config = S.merge(&#123;&#125;, defaultConfig, config);</span><br><span class="line">    <span class="keyword">return</span> React.render(<span class="xml"><span class="tag">&lt;<span class="title">Component</span> &#123;<span class="attribute">...config</span>&#125;/&gt;</span>, container);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return Component;</span><br><span class="line">&#125;);</span></span><br></pre></td></tr></table></figure>
<p>可以看到，返回一个React类，这个类提供了静态方法用于在容器中直接绘制组件，方便原生JS，而JSX中也可以直接使用标签的方式使用组件</p>
<p>对于上面说的三点：</p>
<ol>
<li>配置数据props的传入：原生JS采用init方法传入，JSX直接写在标签上</li>
<li>内部数据state组件维护</li>
<li>组件的方法和事件，对于原生JS提供了getValue、setValue这样的方法，而对于JSX使用则直接可以通过配置传入。对于事件的处理采用了混入Event模型的方式，为组件自身提供了on、off、fire这种事件模型方法供原生JS使用，而对于JSX的调用方式，则直接使用onXXX风格的回调即可</li>
</ol>
<p>这样组件就可以兼容外层是JSX或外层是JS的调用方式，同时兼容新业务和老业务</p>
<h4 id="组件独立性">组件独立性</h4><p>同时，一个组件应当保证对应的独立性：</p>
<ol>
<li>样式的独立</li>
<li>DOM的独立</li>
<li>组件逻辑的独立</li>
</ol>
<p>个人认为一个组件应该standalone就能跑起来的，React非常好的提供了DOM的独立和组件逻辑的独立，采用inline-style的方式也能提供样式的独立。其中DOM的独立非常重要，一旦多个组件DOM形成耦合，这几个组件的解耦将异常困难。React组件的每个DOM元素都分配了自己的id，一旦修改就会发生错误，强制了DOM的独立。</p>
<p>这样组件就只关注自己了，那么问题就来了，组件都只关注自己，组件之间交互怎么办？所以有Flux</p>
<h4 id="模块间通信">模块间通信</h4><p>React解决了组件实现，组件间通信就交给了Flux的模式，Flux是一种数据通信模式，其实说简单点就是全局有一些保存数据的Store，各个React组件相互之间通信不是直接通信，而是通过这些保存数据的Store，一个组件修改Store递交数据，另外一个组件监听Store的变化获得数据来实现数据的传输。不过数据传输是单向的</p>
<p>以往组件之间的耦合是因为一个组件直接调用了另外一个组件的接口，现在大家都不依赖接口了，直接依赖数据，从主动调用变成了被动通知变更</p>
<p>这里有几个点：</p>
<ol>
<li>一个数据需求模块初始化后，一直在监听数据变化，但变更数据的模块可能根本就不存在，这个数据需求模块就蛋疼了，其实当不存在数据变更模块的时候，这个数据需求模块是不应该被初始化的</li>
<li>由于数据需求模块只在乎数据，给他的数据长啥样，它就长啥样，多个模块共同修改同一份数据时，永远是最新的数据决定了模块的展示，数据需求模块本身必须是无状态的，因为它没办法保证它所依赖的多份数据的递交顺序</li>
<li>数据需求模块依赖的数据结构是定死的， 变更数据的模块吐出来的数据结果也是定死的，这就产生一个问题，这两个定死的数据结构需要做适配，每个模块只关注自身，当然不应该考虑为其他模块做数据适配。所以这个适配就得在Flux上做，需要尽可能的通过定义开发规范来减少数据适配的出现</li>
<li>需要immutable保证数据本身的独立性，防止交叉修改同一份数据导致数据污染</li>
<li>数据都是整块递交，需要DOM Diff这样的方式来保证重绘范围尽可能小</li>
</ol>
<h3 id="Webpack和Browserify">Webpack和Browserify</h3><p>这俩的运行机制大体上来说就是分析Common JS代码的AST语法树，找到其中的require指定的依赖名称，然后递归的分析依赖，最后将所有的依赖打包在一起，并配合打包工具自己的模块加载机制复写或替换require实现加载。采用这种方式，组件的安装和使用变得和Common JS一样简单，不用考虑组件的版本管理，因为组件在node_modules里面都有对应版本的源码。</p>
<p>但这种方式容易产生性能问题：</p>
<ol>
<li>不少Common JS的模块都有自己依赖的工具包，这些工具包的版本通常并不相同，这也就导致了重复打包的问题</li>
<li>Common JS的模块开发方式使得不少开发者没有在意自己使用的包的大小或内容，往往会为了几个很小的功能而引入一个完整的工具库，这在Node.Js上没什么，但是到了浏览器端，就成了大问题</li>
<li>很多模块没有采用异步加载依赖的方式，而是直接require同步加载依赖，导致打包出来的入口文件巨大无比…首屏很慢</li>
<li>ES 6的打包碎片问题，如果整页打包当然不存在碎片的问题。但是对于多个模块分开打包，就很导致每个模块自己独立打包，会生成自己的一些编译依赖，而通过模块加载器一起使用时，由于模块相互之间独立，这些依赖虽然有很多是相同的，但也会被引入很多次。目前没有什么好的解决办法，就是减少碎片生成。</li>
<li>React组件对于子组件的引入都是同步的，如果整页都是React开发就很容易遇到3中的问题</li>
</ol>
<p>对于一些新业务，用打包工具整页打包还是可行的，但是一定要注意处理好异步加载的模块，同时保证依赖本身的轻量。而对于老业务，则需要减少独立打包时产生的碎片。不管什么开发方式，都需要注意1，2的情况，个人比较倾向的方式就是，最外层依旧采用现有的AMD模块管理方式，而部分模块采用React开发，防止出现5和3的问题，但4的问题就得通过定义开发规范的方式来规避了</p>
<h2 id="最后">最后</h2><p>这里随便写一点，可能个人对于React和打包技术的理解有误导致观点不符。其实还是一点，不同的业务场景有自身的技术取舍，能解决问题的技术就是好技术。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>好久没写东西了，主要是工作比以前学生时代忙多了，周末也是各种加班充电，沉淀的少了。最近一直在用React对手上的老业务做重构，这里写一下重构中的一些感悟和思考</p>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://lingyu.wang/tags/JavaScript/"/>
    
      <category term="React" scheme="http://lingyu.wang/tags/React/"/>
    
      <category term="前端综合" scheme="http://lingyu.wang/categories/%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[轻松入门React和Webpack]]></title>
    <link href="http://lingyu.wang/2015/05/15/react-and-webpack/"/>
    <id>http://lingyu.wang/2015/05/15/react-and-webpack/</id>
    <published>2015-05-14T16:00:00.000Z</published>
    <updated>2015-05-31T15:02:20.000Z</updated>
    <content type="html"><![CDATA[<p>最近在学习React.js，之前都是直接用最原生的方式去写React代码，发现组织起来特别麻烦，之前听人说用Webpack组织React组件得心应手，就花了点时间学习了一下，收获颇丰</p>
<a id="more"></a>
<h2 id="说说React">说说React</h2><p>一个组件，有自己的结构，有自己的逻辑，有自己的样式，会依赖一些资源，会依赖某些其他组件。比如日常写一个组件，比较常规的方式：</p>
<p>－ 通过前端模板引擎定义结构<br>－ JS文件中写自己的逻辑<br>－ CSS中写组件的样式<br>－ 通过RequireJS、SeaJS这样的库来解决模块之间的相互依赖，<br>那么在React中是什么样子呢？</p>
<h3 id="结构和逻辑">结构和逻辑</h3><p>在React的世界里，结构和逻辑交由JSX文件组织，React将模板内嵌到逻辑内部，实现了一个JS代码和HTML混合的JSX。</p>
<h4 id="结构">结构</h4><p>在JSX文件中，可以直接通过<code>React.createClass</code>来定义组件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CustomComponent = React.creatClass(&#123;</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">className</span>=<span class="value">"custom-component"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>通过这种方式可以很方便的定义一个组件，组件的结构定义在render函数中，但这并不是简单的模板引擎，我们可以通过js方便、直观的操控组件结构，比如我想给组件增加几个节点：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CustomComponent = React.creatClass(&#123;</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> $nodes = [<span class="string">'h'</span>,<span class="string">'e'</span>,<span class="string">'l'</span>,<span class="string">'l'</span>,<span class="string">'o'</span>].map(<span class="function"><span class="keyword">function</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="title">span</span>&gt;</span>&#123;str&#125;<span class="tag">&lt;/<span class="title">span</span>&gt;</span>)</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">className</span>=<span class="value">"custom-component"</span>&gt;</span>&#123;$nodes&#125;<span class="tag">&lt;/<span class="title">div</span>&gt;</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>通过这种方式，React使得组件拥有灵活的结构。那么React又是如何处理逻辑的呢？</p>
<h4 id="逻辑">逻辑</h4><p>写过前端组件的人都知道，组件通常首先需要相应自身DOM事件，做一些处理。必要时候还需要暴露一些外部接口，那么React组件要怎么做到这两点呢？</p>
<h5 id="事件响应">事件响应</h5><p>比如我有个按钮组件，点击之后需要做一些处理逻辑，那么React组件大致上长这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ButtonComponent = React.createClass(&#123;</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="title">button</span>&gt;</span>屠龙宝刀，点击就送<span class="tag">&lt;/<span class="title">button</span>&gt;</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>点击按钮应当触发相应地逻辑，一种比较直观的方式就是给button绑定一个<code>onclick</code>事件，里面就是需要执行的逻辑了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDragonKillingSword</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//送宝刀</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ButtonComponent = React.createClass(&#123;</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="title">button</span> <span class="attribute">onclick</span>=<span class="value">"getDragonKillingSword()"</span>&gt;</span>屠龙宝刀，点击就送<span class="tag">&lt;/<span class="title">button</span>&gt;</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>但事实上<code>getDragonKillingSword()</code>的逻辑属于组件内部行为，显然应当包装在组件内部，于是在React中就可以这么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ButtonComponent = React.createClass(&#123;</span><br><span class="line">    getDragonKillingSword: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//送宝刀</span></span><br><span class="line">    &#125;,</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="title">button</span> <span class="attribute">onClick</span>=<span class="value">&#123;this.getDragonKillingSword&#125;</span>&gt;</span>屠龙宝刀，点击就送<span class="tag">&lt;/<span class="title">button</span>&gt;</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这样就实现内部事件的响应了，那如果需要暴露接口怎么办呢？</p>
<h5 id="暴露接口">暴露接口</h5><p>事实上现在<code>getDragonKillingSword</code>已经是一个接口了，如果有一个父组件，想要调用这个接口怎么办呢？</p>
<p>父组件大概长这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ImDaddyComponent = React.createClass(&#123;</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="title">div</span>&gt;</span></span><br><span class="line">                //其他组件</span><br><span class="line">                <span class="tag">&lt;<span class="title">ButtonComponent</span> /&gt;</span></span><br><span class="line">                //其他组件</span><br><span class="line">            <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">        )</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>那么如果想手动调用组件的方法，首先在ButtonComponent上设置一个<code>ref=&quot;&quot;</code>属性来标记一下，比如这里把子组件设置成<code>&lt;ButtonComponent ref=&quot;getSwordButton&quot;/&gt;</code>，那么在父组件的逻辑里，就可以在父组件自己的方法中通过这种方式来调用接口方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.refs.getSwordButton.getDragonKillingSword();</span><br></pre></td></tr></table></figure>
<p>看起来屌屌哒~那么问题又来了，父组件希望自己能够按钮点击时调用的方法，那该怎么办呢？</p>
<h5 id="配置参数">配置参数</h5><p>父组件可以直接将需要执行的函数传递给子组件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ButtonComponent clickCallback=&#123;<span class="keyword">this</span>.getSwordButtonClickCallback&#125;/&gt;</span><br></pre></td></tr></table></figure>
<p>然后在子组件中调用父组件方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ButtonComponent = React.createClass(&#123;</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="title">button</span> <span class="attribute">onClick</span>=<span class="value">&#123;this.props.clickCallback&#125;</span>&gt;</span>屠龙宝刀，点击就送<span class="tag">&lt;/<span class="title">button</span>&gt;</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>子组件通过<code>this.props</code>能够获取在父组件创建子组件时传入的任何参数，因此<code>this.props</code>也常被当做配置参数来使用</p>
<p>屠龙宝刀每个人只能领取一把，按钮点击一下就应该灰掉，应当在子组件中增加一个是否点击过的状态，这又应当处理呢？</p>
<h5 id="组件状态">组件状态</h5><p>在React中，每个组件都有自己的状态，可以在自身的方法中通过<code>this.state</code>取到，而初始状态则通过<code>getInitialState()</code>方法来定义，比如这个屠龙宝刀按钮组件，它的初始状态应该是没有点击过，所以<code>getInitialState</code>方法里面应当定义初始状态<code>clicked: false</code>。而在点击执行的方法中，应当修改这个状态值为<code>click: true</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ButtonComponent = React.createClass(&#123;</span><br><span class="line">    getInitialState: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//确定初始状态</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            clicked: <span class="literal">false</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    getDragonKillingSword: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//送宝刀</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//修改点击状态</span></span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            clicked: <span class="literal">true</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="title">button</span> <span class="attribute">onClick</span>=<span class="value">&#123;this.getDragonKillingSword&#125;</span>&gt;</span>屠龙宝刀，点击就送<span class="tag">&lt;/<span class="title">button</span>&gt;</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这样点击状态的维护就完成了，那么render函数中也应当根据状态来维护节点的样式，比如这里将按钮设置为<code>disabled</code>，那么render函数就要添加相应的判断逻辑：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clicked = <span class="keyword">this</span>.state.clicked;</span><br><span class="line">    <span class="keyword">if</span>(clicked)</span><br><span class="line">        <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="title">button</span> <span class="attribute">disabled</span>=<span class="value">"disabled"</span> <span class="attribute">onClick</span>=<span class="value">&#123;this.getDragonKillingSword&#125;</span>&gt;</span>屠龙宝刀，点击就送<span class="tag">&lt;/<span class="title">button</span>&gt;</span>)</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="title">button</span> <span class="attribute">onClick</span>=<span class="value">&#123;this.getDragonKillingSword&#125;</span>&gt;</span>屠龙宝刀，点击就送<span class="tag">&lt;/<span class="title">button</span>&gt;</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="小节">小节</h4><p>这里简单介绍了通过JSX来管理组件的结构和逻辑，事实上React给组件还定义了很多方法，以及组件自身的生命周期，这些都使得组件的逻辑处理更加强大</p>
<h3 id="资源加载">资源加载</h3><p>CSS文件定义了组件的样式，现在的模块加载器通常都能够加载CSS文件，如果不能一般也提供了相应的插件。事实上CSS、图片可以看做是一种资源，因为加载过来后一般不需要做什么处理。</p>
<p>React对这一方面并没有做特别的处理，虽然它提供了Inline Style的方式把CSS写在JSX里面，但估计没有多少人会去尝试，毕竟现在CSS样式已经不再只是简单的CSS文件了，通常都会去用Less、Sass等预处理，然后再用像postcss、myth、autoprefixer、cssmin等等后处理。资源加载一般也就简单粗暴地使用模块加载器完成了</p>
<h3 id="组件依赖">组件依赖</h3><p>组件依赖的处理一般分为两个部分：组件加载和组件使用</p>
<h4 id="组件加载">组件加载</h4><p>React没有提供相关的组件加载方法，依旧需要通过<code>&lt;script&gt;</code>标签引入，或者使用模块加载器加载组件的JSX和资源文件。</p>
<h4 id="组件使用">组件使用</h4><p>如果细心，就会发现其实之前已经有使用的例子了，要想在一个组件中使用另外一个组件，比如在<code>ParentComponent</code>中使用<code>ChildComponent</code>，就只需要在<code>ParentComponent</code>的<code>render()</code>方法中写上<code>&lt;ChildComponent /&gt;</code>就行了，必要的时候还可以传些参数。</p>
<h3 id="疑问">疑问</h3><p>到这里就会发现一个问题，React除了只处理了结构和逻辑，资源也不管，依赖也不管。是的，React将近两万行代码，连个模块加载器都没有提供，更与Angularjs，jQuery等不同的是，他还不带啥脚手架…没有Ajax库，没有Promise库，要啥啥没有…</p>
<h4 id="虚拟DOM">虚拟DOM</h4><p>那它为啥这么大？因为它实现了一个虚拟DOM（Virtual DOM）。虚拟DOM是干什么的？这就要从浏览器本身讲起</p>
<p>如我们所知，在浏览器渲染网页的过程中，加载到HTML文档后，会将文档解析并构建DOM树，然后将其与解析CSS生成的CSSOM树一起结合产生爱的结晶——RenderObject树，然后将RenderObject树渲染成页面（当然中间可能会有一些优化，比如RenderLayer树）。这些过程都存在与渲染引擎之中，渲染引擎在浏览器中是于JavaScript引擎（JavaScriptCore也好V8也好）分离开的，但为了方便JS操作DOM结构，渲染引擎会暴露一些接口供JavaScript调用。由于这两块相互分离，通信是需要付出代价的，因此JavaScript调用DOM提供的接口性能不咋地。各种性能优化的最佳实践也都在尽可能的减少DOM操作次数。</p>
<p>而虚拟DOM干了什么？它直接用JavaScript实现了DOM树（大致上）。组件的HTML结构并不会直接生成DOM，而是映射生成虚拟的JavaScript DOM结构，React又通过在这个虚拟DOM上实现了一个 diff 算法找出最小变更，再把这些变更写入实际的DOM中。这个虚拟DOM以JS结构的形式存在，计算性能会比较好，而且由于减少了实际DOM操作次数，性能会有较大提升</p>
<p><strong>道理我都懂，可是为什么我们没有模块加载器？</strong></p>
<p>所以就需要Webpack了</p>
<h2 id="说说Webpack">说说Webpack</h2><h3 id="什么是Webpack？">什么是Webpack？</h3><p>事实上它是一个打包工具，而不是像RequireJS或SeaJS这样的模块加载器，通过使用Webpack，能够像Node.js一样处理依赖关系，然后解析出模块之间的依赖，将代码打包</p>
<h3 id="安装Webpack">安装Webpack</h3><p>首先得有Node.js</p>
<p>然后通过<code>npm install -g webpack</code>安装webpack，当然也可以通过gulp来处理webpack任务，如果使用gulp的话就<code>npm install --save-dev gulp-webpack</code></p>
<h3 id="配置Webpack">配置Webpack</h3><p>Webpack的构建过程需要一个配置文件，一个典型的配置文件大概就是这样</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">var</span> commonsPlugin = <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(<span class="string">'common.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        entry1: <span class="string">'./entry/entry1.js'</span>,</span><br><span class="line">        entry2: <span class="string">'./entry/entry2.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: __dirname,</span><br><span class="line">        filename: <span class="string">'[name].entry.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    resolve: &#123;</span><br><span class="line">        extensions: [<span class="string">''</span>, <span class="string">'.js'</span>, <span class="string">'.jsx'</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        loaders: [&#123;</span><br><span class="line">            test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">            loader: <span class="string">'babel-loader'</span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            test: <span class="regexp">/\.jsx$/</span>,</span><br><span class="line">            loader: <span class="string">'babel-loader!jsx-loader?harmony'</span></span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [commonsPlugin]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里对Webpack的打包行为做了配置，主要分为几个部分：</p>
<ul>
<li>entry：指定打包的入口文件，每有一个键值对，就是一个入口文件</li>
<li>output：配置打包结果，path定义了输出的文件夹，filename则定义了打包结果文件的名称，filename里面的<code>[name]</code>会由entry中的键（这里是entry1和entry2）替换</li>
<li>resolve：定义了解析模块路径时的配置，常用的就是extensions，可以用来指定模块的后缀，这样在引入模块时就不需要写后缀了，会自动补全</li>
<li>module：定义了对模块的处理逻辑，这里可以用loaders定义了一系列的加载器，以及一些正则。当需要加载的文件匹配test的正则时，就会调用后面的loader对文件进行处理，这正是webpack强大的原因。比如这里定义了凡是<code>.js</code>结尾的文件都是用<code>babel-loader</code>做处理，而<code>.jsx</code>结尾的文件会先经过<code>jsx-loader</code>处理，然后经过<code>babel-loader</code>处理。当然这些loader也需要通过<code>npm install</code>安装</li>
<li>plugins: 这里定义了需要使用的插件，比如commonsPlugin在打包多个入口文件时会提取出公用的部分，生成common.js</li>
</ul>
<p>当然Webpack还有很多其他的配置，具体可以参照它的<a href="http://webpack.github.io/docs/configuration.html#entry" target="_blank" rel="external">配置文档</a></p>
<h3 id="执行打包">执行打包</h3><p>如果通过<code>npm install -g webpack</code>方式安装webpack的话，可以通过命令行直接执行打包命令，比如这样：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$webpack --config webpack.config.js</span><br></pre></td></tr></table></figure>
<p>这样就会读取当前目录下的webpack.config.js作为配置文件执行打包操作</p>
<p>如果是通过gulp插件gulp-webpack，则可以在gulpfile中写上gulp任务：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'gulp-webpack'</span>);</span><br><span class="line"><span class="keyword">var</span> webpackConfig = <span class="built_in">require</span>(<span class="string">'./webpack.config'</span>);</span><br><span class="line">gulp.task(<span class="string">"webpack"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp</span><br><span class="line">        .src(<span class="string">'./'</span>)</span><br><span class="line">        .pipe(webpack(webpackConfig))</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./build'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="组件编写">组件编写</h3><h4 id="使用Babel提升逼格">使用Babel提升逼格</h4><p>Webpack使得我们可以使用Node.js的CommonJS规范来编写模块，比如一个简单的Hello world模块，就可以这么处理：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> React = <span class="built_in">require</span>(<span class="string">'react'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> HelloWorldComponent = React.createClass(&#123;</span><br><span class="line">    displayName: <span class="string">'HelloWorldComponent'</span>,</span><br><span class="line">    render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="title">div</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="title">div</span>&gt;</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = HelloWorldComponent;</span><br></pre></td></tr></table></figure>
<p>等等，这和之前的写法没啥差别啊，依旧没有逼格…程序员敲码要有geek范，要逼格than逼格，这太low了。现在都ES6了，React的代码也要写ES6，<code>babel-loader</code>就是干这个的。<a href="https://babeljs.io/" target="_blank" rel="external">Babel</a>能够将ES6代码转换成ES5。首先需要通过命令<code>npm install --save-dev babel-loader</code>来进行安装，安装完成后就可以使用了，一种使用方式是之前介绍的在<code>webpack.config.js</code>的loaders中配置，另一种是直接在代码中使用，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> HelloWorldComponent = <span class="built_in">require</span>(<span class="string">'!babel!jsx!./HelloWorldComponent'</span>);</span><br></pre></td></tr></table></figure>
<p>那我们应当如何使用Babel提升代码的逼格呢？改造一下之前的HelloWorld代码吧：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="title">div</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="title">div</span>&gt;</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样在其他组件中需要引入HelloWorldComponent组件，就只要就可以了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> HelloWorldComponent <span class="keyword">from</span> <span class="string">'./HelloWorldComponent'</span></span><br></pre></td></tr></table></figure>
<p>怎么样是不是更有逼格了？通过import引入模块，还可以直接定义类和类的继承关系，这里也不再需要<code>getInitialState</code>了，直接在构造函数<code>constructor</code>中用<code>this.state = xxx</code>就好了</p>
<p>Babel带来的当然还不止这些，在其帮助下还能尝试很多优秀的ES6特性，比如箭头函数，箭头函数的特点就是内部的this和外部保持一致，从此可以和<code>that</code>、<code>_this</code>说再见了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'H'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>].map((c) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="title">span</span>&gt;</span>&#123;c&#125;<span class="tag">&lt;/<span class="title">span</span>&gt;</span>)</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>其他还有很多，具体可以参照<a href="https://babeljs.io/docs/learn-es6/" target="_blank" rel="external">Babel的学习文档</a></p>
<h4 id="样式编写">样式编写</h4><p>我是一个强烈地Less依赖患者，脱离了Less直接写CSS就会出现四肢乏力、不想干活、心情烦躁等现象，而且还不喜欢在写Less时候加前缀，平常都是gulp+less+autoprefixer直接处理的，那么在Webpack组织的React组件中要怎么写呢？</p>
<p><strong>没错，依旧是使用loader</strong></p>
<p>可以在<code>webpack.config.js</code>的loaders中增加Less的配置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">  loader: <span class="string">'style-loader!css-loader!autoprefixer-loader!less-loader'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这样的配置，就可以直接在模块代码中引入Less样式了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./HelloWorldComponent.less'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="title">div</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="title">div</span>&gt;</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="其他">其他</h4><p>Webpack的loader为React组件化提供了很多帮助，像图片也提供了相关的loader：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; test: <span class="regexp">/\.png$/</span>, loader: <span class="string">"url-loader?mimetype=image/png"</span> &#125;</span><br></pre></td></tr></table></figure>
<p>更多地loader可以移步<a href="https://github.com/webpack/docs/wiki/list-of-loaders" target="_blank" rel="external">webpack的wiki</a></p>
<h2 id="在Webpack下实时调试React组件">在Webpack下实时调试React组件</h2><p>Webpack和React结合的另一个强大的地方就是，在修改了组件源码之后，不刷新页面就能把修改同步到页面上。这里需要用到两个库<code>webpack-dev-server</code>和<code>react-hot-loader</code>。</p>
<p>首先需要安装这两个库，<code>npm install --save-dev webpack-dev-server react-hot-loader</code></p>
<p>安装完成后，就要开始配置了，首先需要修改entry配置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">  helloworld: [</span><br><span class="line">    <span class="string">'webpack-dev-server/client?http://localhost:3000'</span>,</span><br><span class="line">    <span class="string">'webpack/hot/only-dev-server'</span>,</span><br><span class="line">    <span class="string">'./helloworld'</span></span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>通过这种方式指定资源热启动对应的服务器，然后需要配置<code>react-hot-loader</code>到loaders的配置当中，比如我的所有组件代码全部放在scripts文件夹下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.js?$/</span>,</span><br><span class="line">  loaders: [<span class="string">'react-hot'</span>, <span class="string">'babel'</span>],</span><br><span class="line">  include: [path.join(__dirname, <span class="string">'scripts'</span>)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后配置一下plugins，加上热替换的插件和防止报错的插件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(),</span><br><span class="line">  <span class="keyword">new</span> webpack.NoErrorsPlugin()</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>这样配置就完成了，但是现在要调试需要启动一个服务器，而且之前配置里映射到<code>http://localhost:3000</code>，所以就在本地3000端口起个服务器吧，在项目根目录下面建个server.js：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">var</span> WebpackDevServer = <span class="built_in">require</span>(<span class="string">'webpack-dev-server'</span>);</span><br><span class="line"><span class="keyword">var</span> config = <span class="built_in">require</span>(<span class="string">'./webpack.config'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> WebpackDevServer(webpack(config), &#123;</span><br><span class="line">  publicPath: config.output.publicPath,</span><br><span class="line">  hot: <span class="literal">true</span>,</span><br><span class="line">  historyApiFallback: <span class="literal">true</span></span><br><span class="line">&#125;).listen(<span class="number">3000</span>, <span class="string">'localhost'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="built_in">console</span>.log(err);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Listening at localhost:3000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这样就可以在本地3000端口开启调试服务器了，比如我的页面是根目录下地<code>index.html</code>，就可以直接通过<code>http://localhost:3000/index.html</code>访问页面，修改React组件后页面也会被同步修改，这里貌似使用了websocket来同步数据。图是一个简单的效果：</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/test.gif" alt="Alt text"></p>
<h2 id="结束">结束</h2><p>React的组件化开发很有想法，而Webpack使得React组件编写和管理更加方便，这里只涉及到了React和Webpack得很小一部分，还有更多的最佳实践有待在学习的路上不断发掘</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近在学习React.js，之前都是直接用最原生的方式去写React代码，发现组织起来特别麻烦，之前听人说用Webpack组织React组件得心应手，就花了点时间学习了一下，收获颇丰</p>]]>
    
    </summary>
    
      <category term="React" scheme="http://lingyu.wang/tags/React/"/>
    
      <category term="JS技术" scheme="http://lingyu.wang/categories/JS%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[4月26日杂谈]]></title>
    <link href="http://lingyu.wang/2015/04/26/sometalk-4-26/"/>
    <id>http://lingyu.wang/2015/04/26/sometalk-4-26/</id>
    <published>2015-04-25T16:00:00.000Z</published>
    <updated>2015-05-31T15:02:20.000Z</updated>
    <content type="html"><![CDATA[<p>本来今天打算继续写之前说要写的动画基础知识的，但是晚上玩了玩gitbook就忘掉了。现在也懒得组织了，就把最近写的一些小玩意梳理一下。</p>
<a id="more"></a>
<h2 id="Gitbook">Gitbook</h2><p>我的<a href="http://read.lingyu.wang" target="_blank" rel="external">读书笔记</a>是用Gitbook来生成的，如果之前关注过的人可能会发现最近读书笔记的样式发生了很大的调整。</p>
<p>是的，我把Gitbook从1.x.x升级到了2.x.x了， 升级之后样式更加美观， 也不会有以前的菜单栏有时不出现的bug了。 新入职才发现， 天猫这边的文档现在都是用Gitbook来生成的，<strong>简约，大方</strong>，但是Gitbook不能完全满足我的需求：</p>
<ol>
<li>没法创建书单，很好地用todo list的方式展现要读的书、已读的书</li>
<li>Codepen上有不少好东西，但是没办法嵌入到Gitbook中</li>
<li>图片只是100%，没有做任何处理，如果图片较大就会被压缩，里面的文字就看不清了。 比如我现在用百度脑图写读书笔记， 里面文字就被压的很小了</li>
</ol>
<p>针对这几个问题，我花了点周末时间写了几个插件：</p>
<ol>
<li>生成todo list：<a href="https://github.com/LingyuCoder/gitbook-plugin-todo" target="_blank" rel="external">gitbook-plugin-todo</a>。现在读书笔记<a href="http://read.lingyu.wang/" target="_blank" rel="external">首页</a>就是用这个插件生成的书单</li>
<li>生成codepen：<a href="https://github.com/LingyuCoder/gitbook-plugin-codepen" target="_blank" rel="external">gitbook-plugin-codepen</a>，具体效果可以看<a href="http://read.lingyu.wang/Codepen.html" target="_blank" rel="external">我的Codepen</a>，就是加载有点慢</li>
<li>使用fancybox查看图片：<a href="https://github.com/LingyuCoder/gitbook-plugin-fancybox" target="_blank" rel="external">gitbook-plugin-fancybox</a>，现在点击读书笔记里任何一张图片，都会有个弹窗来展示图片，fancybox是个很强大的jQuery图片展示插件，之前hexo默认也是带fancybox的，现在3.0了就不知道还带不带。fancybox效果真心赞，大图片通过buttons的helper也可以很轻松的查看</li>
</ol>
<h3 id="一点随想">一点随想</h3><p>写这几个插件并不怎么花时间，但是却解决了我的问题，帮我构建了一个更加完善的读书笔记。 <strong>能用来切切实实解决问题、创造出价值的技术，才是真正的技术</strong></p>
<h2 id="React玩具">React玩具</h2><p>最近React-native炒得很热，整个天猫团队也颇为重视，我也尝试着做了做React-native，不过由于React本身都还没玩通，写起来很吃力，因此决定先好好学习一下React，理解React的思想。这也就产出了几个质脆玩具。</p>
<ol>
<li><a href="http://lingyucoder.github.io/learn-react/page/md-editor/index.html" target="_blank" rel="external">markdown编辑器</a></li>
<li><a href="http://lingyucoder.github.io/learn-react/page/calculator/index.html" target="_blank" rel="external">计算器</a></li>
<li><a href="http://lingyucoder.github.io/learn-react/page/calendar/index.html" target="_blank" rel="external">日历</a></li>
</ol>
<p>这些源码都放在我Github的<a href="https://github.com/LingyuCoder/learn-react" target="_blank" rel="external">learn-react</a>仓库下</p>
<p>React用能够很方便的自己定义元素，并且使用定义元素也很简单。通过使用JSX，可以直接将HTML代码写在JSX代码中，组件的结构更加清晰、直观。这与Web Component的组件化思想颇有不同，不过用起来要简便很多。React通过virtual dom，自己构建了一个虚拟的DOM树，在渲染时在虚拟的DOM树上进行diff，只渲染不同的部分，因此性能不错。但是目前有几个问题：</p>
<ol>
<li>虽然JS和HTML实现了组件化，问题是CSS并没有好的管理办法，依旧是和原来一样，相互污染</li>
<li>库的体积比较大，但是还只是解决了V层的问题，不带任何脚手架，一般还需要配合工具库使用</li>
</ol>
<p>React和Angular比较功能还是比较单一的，虽然代码量都是2w+行，但React并不像Angular是一个完整的MVVM框架，当然这样的React的学习成本个人感觉要比Angular低的多，上手很容易。</p>
<h2 id="博客升级">博客升级</h2><p>最近hexo推出3.0了，于是乎手贱就在新发的电脑上装了，发现主题也跪了，之前写的插件也跪了。好吧，还是继续用我的2.5.7了。</p>
<p>这个博客我记得是去年过年时候搭的算下来得有一年多了，以前写的很勤奋，几乎两天一篇，甚至一天一篇。现在懒得几个月才一篇。之前突然陷入了一个怪思维，总觉着要写就得写点牛逼的东西，不能让别人觉得我的博客很low，但是又一直没干啥牛逼的事，也就没牛逼的东西可以写…恶性循环…</p>
<p>仔细想一想：<strong>这是我的博客，我想咋写咋写，我爱咋写咋写，爱看看，不看ctrl+w就是</strong>。于是乎又有了写东西的动力</p>
<h2 id="关于日记">关于日记</h2><p>可能有人留意到博客首页上有一个<a href="http://lingyu.wang/everyday">日记</a>，但估计很少有人点进去，我也懒得在里面放百度统计看看有多少流量了，反正整站才每天100左右，那里肯定也就个位数</p>
<p>我从小到大写日记从来没坚持超过两周，但是在那上面竟然写了5个月…虽然经常几天才更新上传一次，但基本上都连下来了。现在保证一天看两篇技术文章，然后把收获写在里面</p>
<p>说实话有很多文章看完连收货都没有</p>
<p>关于这些文章我有一套管理流程：</p>
<p>首先是文章的出处：我订阅了一些邮件，他们会定时向我推送一些文章，这些邮件有</p>
<ul>
<li>奇舞团周刊</li>
<li>好东西传送门</li>
<li>开发者头条</li>
<li>JavaScript Weekly</li>
<li>DailyJS</li>
<li>Web Tools Weekly</li>
<li>SegmentFault • 每周精选</li>
</ul>
<p>另外在日常刷微博过程中，看到别人转发的文章，比如知乎、乱炖、W3CTech上的文章，我也会mark保存下来。那么这么多文章，怎么把他们汇总存储，有时间就去看呢？</p>
<p><strong>这就要用到一件神器：印象笔记——剪藏</strong></p>
<p>剪藏是个印象笔记的Chrome插件，在打开网页后，点击一下剪藏按钮，它就能自动提取正文部分内容，保存到印象笔记里面。然后我在印象笔记里弄了一个笔记本，专门用来放这些还没有看的文章。等到有时间（比如蹲马桶，闲的蛋疼，吃饱不想干活）的时候，就会从里面随便找点文章看一看</p>
<p>我还特地在印象笔记里面弄了个笔记本分组，里面有很多笔记本，专门用于归档这些文章，看完之后觉得有价值的文章就会根据内容放到特定的笔记本中</p>
<p><strong>这一切都建立在你肯出30块每月的印象笔记高级用户的基础上</strong></p>
<h2 id="其他">其他</h2><p>最近还想写一篇文章，推荐一些觉得不错的Mac工具。不过可能工作上会比较忙，有时间就写写吧</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本来今天打算继续写之前说要写的动画基础知识的，但是晚上玩了玩gitbook就忘掉了。现在也懒得组织了，就把最近写的一些小玩意梳理一下。</p>]]>
    
    </summary>
    
      <category term="思考" scheme="http://lingyu.wang/tags/%E6%80%9D%E8%80%83/"/>
    
      <category term="思考总结" scheme="http://lingyu.wang/categories/%E6%80%9D%E8%80%83%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[前端动画对比]]></title>
    <link href="http://lingyu.wang/2015/04/18/learn-canvas-1/"/>
    <id>http://lingyu.wang/2015/04/18/learn-canvas-1/</id>
    <published>2015-04-17T16:00:00.000Z</published>
    <updated>2015-05-31T15:00:49.000Z</updated>
    <content type="html"><![CDATA[<p>将近三个月没写文章了，就在这三个月内，我从一只学生狗变成了上班族。现在一切都稳定下来了，决定重新开始写点东西了。以后的计划是每周一篇，努力坚持~</p>
<p>之前玩了很长时间的Canvas动画，也写了一些工具和一些demo，放在了我Github上的<a href="https://github.com/LingyuCoder/learn-canvas" target="_blank" rel="external">learn-canvas</a>仓库里。在学习Canvas动画的过程中学到了不少宝贵的新知识，这篇主要是个人对于Canvas动画的一些想法以及与其他前端动画实现的一些对比。</p>
<a id="more"></a>
<h2 id="动画？">动画？</h2><p>几年前，网页开发主要的侧重点还在于功能的实现。那时候的界面虽然不漂亮甚至很丑，但只要提供了用户切实需要的功能，也往往能够得到认可。但如今，随着互联网的快速发展，提供相同功能的互联网产品层出不穷，相互之间的竞争也日益增大。</p>
<p>互联网产品与传统的软件产品不同，以前用户通常是通过购买软件安装软体来获取服务，这种方式使得用户在竞品之间相互转换的代价很高，因此产品往往会有一批自己的用户，竞品相互之间会各有一片领地，然后通过销售、广告等等渠道缓慢的蚕食对手的地盘。</p>
<p>然而互联网产品的情境就完全不同了，用户只需要在浏览器中敲入一个网址，就可以轻松的获取服务。这方便了产品的推广和传播，同时也大大降低了用户对于产品的依赖程度，用户可以很方便的获取到其他同类产品的服务。因此服务提供商就需要想尽各种办法来留住用户。</p>
<p>当然留住用户的方法有很多，比如提供竞品没有的功能、仔细研究特殊用户群的痛点并提供针对性的解决方案等等，但其中的一个比较直接的方式就是“让我们的产品用起来比别人的用起来爽”，说白了也就是提升用户体验。浏览器的性能提升以及对CSS3和HTML5规范的支持，为用户带来了多种多样前所未有的互联网产品体验，动画就是其中一个。</p>
<p>动画给用户带来的体验提升是非常直接的，添加了动画后，信息的展现不再是冰冷冷的文字和图片，变得更加生动、直观，各种模仿现实的动画效果也使得页面元素的展现更加自然、亲切。在页面上实现动画比较常见的有三种方法：</p>
<ol>
<li>CSS动画</li>
<li>JavaScript动画</li>
<li>Canvas、WebGL动画</li>
</ol>
<p>这里就说说这三种动画</p>
<h2 id="CSS动画">CSS动画</h2><p>CSS3可以很方便的通过修改页面元素的样式来实现动画，主要是两种：<code>transition</code>和<code>animation</code>：</p>
<h3 id="transition">transition</h3><p><code>transition</code>为状态的转变提供了过渡动画，比如<code>transition: width 1s linear</code>，如果当前宽度为200，修改其宽度为400，那么就会发生一个时长为1s的动画，在这个动画过程中宽度逐渐增加转变为400。具体的转变方式由linear这种缓动函数来指定，linear就是线性的变化</p>
<h3 id="animation">animation</h3><p><code>animation</code>则是通过定义<code>keyframes</code>关键帧来实现动画，一个典型的keyframes大致是这个样子的：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@<span class="keyword">keyframes</span> myAnime </span>&#123;</span><br><span class="line">    0% <span class="rules">&#123;</span><br><span class="line">        <span class="rule"><span class="attribute">top</span>:<span class="value"> <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="number">50%</span> &#123;</span><br><span class="line">        top: <span class="number">200px</span></span></span>;</span><br><span class="line">    &#125;</span>,</span><br><span class="line">    100% <span class="rules">&#123;</span><br><span class="line">        <span class="rule"><span class="attribute">top</span>:<span class="value"> -<span class="number">200px</span></span></span>;   </span><br><span class="line">    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在通过在元素样式中定义<code>animation</code>：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.ele</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">animation</span>:<span class="value"> myAnime <span class="number">5s</span> linear <span class="number">2s</span> infinite alternate</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>通过这种方法就可以让元素动起来，具体每个参数有什么作用，可以去看看W3C或是MDN的介绍</p>
<h3 id="优势和缺陷">优势和缺陷</h3><p>CSS动画有很多优点：</p>
<ol>
<li>写起来很简单，也比较直观，非常适合实现一些元素动效</li>
<li>在绝大部分时间CSS动画的性能都比较好（不触发重布局和重绘，还能使用上GPU加速）</li>
</ol>
<p>但缺陷也很多：</p>
<ol>
<li>动画过程控制能力较弱，逐帧控制不可行</li>
<li>部分浏览器不兼容，现在大部分都可以，尤其是移动端</li>
<li>若触发重布局和重绘，会大幅度降低性能</li>
<li>由于是CSS实现因此有不少局限性（页面滚动动画等）</li>
<li>基于页面元素，不可能实现像素级的渲染控制</li>
</ol>
<h2 id="JavaScript动画">JavaScript动画</h2><p>JavaScript的动画本质上和CSS动画相似，同样是构建在页面元素的基础之上，比如jQuery的<code>$.fn.animate</code>就实现了JavaScript动画。</p>
<p>JavaScript动画本质上就是通过每隔一小段时间修改一次元素的CSS样式来实现动画。由于每一帧元素的样式都需要计算当前时间点所需要展现的样式属性值，因此只要修改计算的方式就能干预动画过程。这种逐帧绘制的方式有很多好处：由于每一帧都能进行干预，因此拥有极强的控制能力，可以单帧的控制、变换，写得好完全可以兼容IE6，并且像页面滚动这样的效果也可以实现。但由于计算过程需要自己实现，因此JavaScript动画往往较为复杂，所以性能上很容易出现问题，而且一般需要依赖外部动画库（不久之后就不需要了）。另外JavaScript动画和CSS动画同样是基于页面元素和CSS样式，因此有自己的局限性，像素级的控制无法实现。</p>
<p>JavaScript动画往往用于CSS动画无法完成动画的场景，比如兼容低级浏览器、实现一些细粒度动画等等</p>
<h2 id="Canvas、WebGL动画">Canvas、WebGL动画</h2><p>Canvas和WebGL分别提供了2D和3D的画布进行绘制，这种绘制脱离元素和CSS，因此可以随心所欲定义绘制方案。这里就以Canvas为主，因为WebGL我不会哈哈。</p>
<p>Canvas本身提供了一系列的绘制方法，但同样需要JavaScript来控制，与JavaScript动画类似。Canvas本质上可以看做一叠白纸，并且提供了一些圆规直尺的工具，然后画一个动画的过程就是：画一帧，然后把换下一张白纸再画下一帧，和童年在书上画翻页动画原理一样。因此Canvas动画的好处有：</p>
<ol>
<li>拥有JavaScript动画的控制能力</li>
<li>完全脱离CSS和元素，绘制的方式和结果完全由自己控制，可以实现像素级别的控制</li>
<li>能够利用GPU加速，性能不错</li>
<li>可以进行画布控制，导入图像或导出图像</li>
<li>可以进行图像分析</li>
</ol>
<p>但是这些好处也是需要付出代价的：</p>
<ol>
<li>所有的绘制细节都要自己去控制，需要大量代码</li>
<li>不再基于CSS和DOM，因此在交互上很麻烦，只能在canvas上监听然后再计算位置投射到对应的元素上</li>
</ol>
<p>由于这种像素级别的控制能力，往往会使用Canvas做游戏和像音频可视化这样的复杂视觉效果</p>
<h2 id="最后">最后</h2><p>今天先写到这里，下一篇写一写Canvas动画里的一些基础知识</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>将近三个月没写文章了，就在这三个月内，我从一只学生狗变成了上班族。现在一切都稳定下来了，决定重新开始写点东西了。以后的计划是每周一篇，努力坚持~</p>
<p>之前玩了很长时间的Canvas动画，也写了一些工具和一些demo，放在了我Github上的<a href="https://github.com/LingyuCoder/learn-canvas">learn-canvas</a>仓库里。在学习Canvas动画的过程中学到了不少宝贵的新知识，这篇主要是个人对于Canvas动画的一些想法以及与其他前端动画实现的一些对比。</p>]]>
    
    </summary>
    
      <category term="Canvas" scheme="http://lingyu.wang/tags/Canvas/"/>
    
      <category term="JavaScript" scheme="http://lingyu.wang/tags/JavaScript/"/>
    
      <category term="动画" scheme="http://lingyu.wang/tags/%E5%8A%A8%E7%94%BB/"/>
    
      <category term="游戏" scheme="http://lingyu.wang/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="游戏开发" scheme="http://lingyu.wang/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[读书破万卷，敲码别走神]]></title>
    <link href="http://lingyu.wang/2015/01/26/18-books/"/>
    <id>http://lingyu.wang/2015/01/26/18-books/</id>
    <published>2015-01-25T16:00:00.000Z</published>
    <updated>2015-05-31T15:00:49.000Z</updated>
    <content type="html"><![CDATA[<p>上一篇文章是去年十一月，时隔两个多月了，这段时间由于毕业论文上屁事太多，没有静下心来写文章做总结。虽然学了不少新姿势，但是一直没在博客上做记录，特地写点东西来清清灰。</p>
<a id="more"></a>
<h2 id="电子书和纸质书">电子书和纸质书</h2><p>这段时间主要的学习方式是读书，双十一的时候在多看、当当上面买了一大堆电子书。相对于纸质书，电子书有很多的好处：</p>
<ol>
<li>装在手机里能够随时随地拿出来品读，有效地利用了碎片化的时间；</li>
<li>大部分书籍（除了PDF）都可以按照自己需要调节文字的大小、文字颜色、背景颜色，即便是晚上宿舍关灯之后，也可以在被窝里看；</li>
<li>各种电子资源相当便宜，双十一、双十二的时候，多看的书大幅度降价，当当上甚至各种一元一本，对于一些经典书籍（三国、水浒什么的），网上资源也非常多，很容易下载到；</li>
<li>书籍、笔记都在云端，即便更换了设备，也可以登录账号随时下载同步，到哪都能看，也更容易做到“学而时习之”。搬家的时候也轻便得多，我现在就愁宿舍书架上那些纸质书怎么搬走…</li>
</ol>
<p>电子书好处颇多，但相对于纸质书也有不少的不足：</p>
<ol>
<li>排版限制，这是一个很麻烦的问题。比如txt、epub等格式，可以使用电子书阅读软件随意更改字体大小，布局灵活，但在展示像代码这种对布局强依赖的内容时，阅读体验非常差；</li>
<li>书籍限制，各种书籍在出版时依然是纸质书籍为主，虽然电子书阅读软件提供商会购买版权，但书籍数量相当有限，目前电子书覆盖的主要是一些比较经典的书籍和一些网络文学，基本上比较新的书都没有，像一些计算机书籍就算很经典也由于排版调整麻烦所以数量很少（代码多的书籍比较少，理念型的倒还挺多的）；</li>
<li>电子书看书的时候，缺少纸张翻动的感觉，我们在长时间阅读纸质书籍过程中养成的一些阅读习惯都将回归于零。在阅读时经常会需要回头翻看之前的内容，这种需求在纸质书上就很好实现，而在电子书上就颇为吃力；</li>
</ol>
<p>这些都是最近看电子书感受到的，电子阅读还在快速的发展，希望以后在各个阅读平台上能够收录更多的书籍，解决排版限制。至于阅读习惯问题，见仁见智了</p>
<h2 id="书评">书评</h2><p>最近的一些书，计算机相关的书籍占绝大多数，有些记了读书笔记，都放在<a href="http://read.lingyu.wang/" target="_blank" rel="external">我的笔记</a>里。读书笔记使用gitbook搭建，做了一些小修改，里面的内容由于都是一些书籍中的摘抄，所以基本上都是一句一句的，而不组织成文章。</p>
<p><strong>所有的书评仅代表个人观点</strong></p>
<h3 id="产品设计师技能书：知乎马力自选集">产品设计师技能书：知乎马力自选集</h3><p>作者：马力</p>
<p>个人评分：★★★★★</p>
<p><a href="http://read.lingyu.wang/zhihu-product-design/README.html" target="_blank" rel="external">读书笔记</a></p>
<p>一系列文章组成的文集，最初发表在知乎上，作者自己甄选、修改后发布。这种文集的质量一般都比较高。所有内容都是作者的经验总结，阐述了产品、设计、用户之间的关系，阐述了很多经过千锤百炼的产品设计理念，还有很多用户研究的沉淀，非常给力</p>
<h3 id="移动设计">移动设计</h3><p>作者：傅小贞 胡甲超 郑元拢</p>
<p>个人评分：★★★★★</p>
<p><a href="http://read.lingyu.wang/mobile-design/README.html" target="_blank" rel="external">读书笔记</a></p>
<p>我本身不是设计师，但这本书并没有给我带来任何理解障碍。书中结合移动端特有的种种特征，与PC端进行了充分对比，阐述了很多移动端交互、视觉设计的金科玉律，总结出不少优秀的理念和模式。最难能可贵的是，对于所有理念和模式，都辅佐以大量的真实产品实例，直观而生动。</p>
<h3 id="黑客与画家">黑客与画家</h3><p>作者：Paul Graham</p>
<p>个人评分：★★★★★</p>
<p>又是一本文集，一本经典之作。作者在人性、个人学习、黑客文化、互联网革命、个人财富、产品设计、创业、编程语言等等方面都有很多独到的见解。阮一峰翻译的，翻译功底了得。收获很多，最近正在整理这本书笔记</p>
<h3 id="产品设计七日修行">产品设计七日修行</h3><p>作者：侯振宇</p>
<p>个人评分：★★★★★</p>
<p><a href="http://read.lingyu.wang/7-day-product-design/README.html" target="_blank" rel="external">读书笔记</a></p>
<p>也是一本文集，同样是作者心血历程的经验总结，内容很少，但字字珠玑。阐述了设计一个产品时应当注意的方方面面，以及一些重要的产品理念</p>
<h3 id="Web站点优化">Web站点优化</h3><p>作者：Andrew B. King</p>
<p>个人评分：★★★★★</p>
<p>这本书干货很多，非常详尽的阐述了如何对站点做SEO和性能优化。在提供各种优化方法的同时，还提供了很多的指标用于量化优化效果。虽然有一段时间了，但里面的知识依旧非常实用，不过干货实在太多了，而且比较抽象，吸收比较困难</p>
<h3 id="人性的优点">人性的优点</h3><p>作者：卡耐基</p>
<p>个人评分：★★★★★</p>
<p><a href="http://read.lingyu.wang/how-to-stop-worrying-and-start-living/README.html" target="_blank" rel="external">读书笔记</a></p>
<p>一本读起来热血沸腾的励志书，整本书都是满满的正能量。这本书教导读者抛弃忧虑、相信自我、坚定目标，并提供了一套方法去实现自己的梦想，里面有很多的真人真事来论证方法的正确性，理念通俗易懂，难就难在自身付诸行动</p>
<h3 id="人性的弱点">人性的弱点</h3><p>作者：卡耐基</p>
<p>个人评分：★★★★★</p>
<p><a href="http://read.lingyu.wang/how-to-win-friends-and-influence-people/README.html" target="_blank" rel="external">读书笔记</a></p>
<p>一本教人处理人际关系的书，指导读者如何受他人欢迎、如何受他人信任、如何说服他人以及如何建立和睦家庭。卡耐基的书都是阐述各种道理的同时，通过一些真人真事来论证理论的真确性，通俗易懂。读这本书最大的收获就是自省的依据：根据这些标准，自己日常言行是否欠妥，是否有更好地选择。个人这一方面亟待加强</p>
<h3 id="笑侃NBA">笑侃NBA</h3><p>作者：杨毅</p>
<p>个人评分：★★★★</p>
<p>杨毅的解说就很有意思，比较逗比。这本书用说书的方式讲述了一些知名球星的成长历程和他们经历的酸甜苦辣，很多都是老球迷耳熟能详的故事，挺有意思的</p>
<h3 id="编写可读代码的艺术">编写可读代码的艺术</h3><p>作者：Dustin Boswell</p>
<p>个人评分：★★★★★</p>
<p><a href="http://read.lingyu.wang/the-art-of-readable-code/README.html" target="_blank" rel="external">读书笔记</a></p>
<p>一本告诉读者应该如何写可读代码的书。程序员写程序和艺术家创作艺术作品一样，需要有美感，需要认真。这本书阐述了如何写有美感、认真的代码，并从变量命名、语句、注释、循环逻辑、表达式拆分等等具体方面给出了给出了很多例子和细致的修改建议，非常值得阅读，并作为自己编写代码的准则加以实践</p>
<h3 id="淘宝产品十年事">淘宝产品十年事</h3><p>作者：苏杰</p>
<p>个人评分：★★★★</p>
<p><a href="http://read.lingyu.wang/taobao-product-10-year/README.html" target="_blank" rel="external">读书笔记</a></p>
<p>这就是一本历史，淘宝产品的历史。通过一个个阿里的真实产品，从买家、卖家、平台等多个角度，总结了不少宝贵的产品经验。虽然业务上优点上的局限性，但是在尊重、理解用户的前提下权衡产品功能的理念广泛受用</p>
<h3 id="软件开发者路线图——从学徒到高手">软件开发者路线图——从学徒到高手</h3><p>作者：Dave H.Hoover</p>
<p>个人评分：★★★★★</p>
<p><a href="http://read.lingyu.wang/apprenticeship-patterns/README.html" target="_blank" rel="external">读书笔记</a></p>
<p>很有用的一本书，针对刚进入计算机行业的新人，给予了切切实实的指导，教授很多宝贵学习方法的同时，帮助读者认清自己、摆正位置、确定职业发展方向。针对所处的场景，给予了很多非常有建设性的建议，读完之后收益匪浅</p>
<h3 id="JavaScript修炼之道">JavaScript修炼之道</h3><p>作者：Christophe Porteneuve</p>
<p>个人评分：★</p>
<p>收获不大，这本书叫JavaScript修炼之道，但对于JavaScript语言本身的学习帮助寥寥。里面都是使用几个特定的框架来完成一些特定的功能。前端更新迭代快速，框架本身淘汰、换代很快，因此书中的知识价值很低，即便是新手也学不到多少东西</p>
<h3 id="HTML5_应用开发实践">HTML5 应用开发实践</h3><p>作者：Zachary Kessin</p>
<p>个人评分：★★★</p>
<p><a href="http://read.lingyu.wang/programming-html5-applications/README.html" target="_blank" rel="external">读书笔记</a></p>
<p>这本书基本上涵盖了H5的本地存储、IndexedDB、File API、Application Cache、Worker、Web Socket、新标记等一些比较重要的功能，但是由于涵盖的内容还是比较多，大都讲了是什么、怎么用起来。可以说是本介绍性质的书籍，较为基础适合初学者。如果对这些H5功能已经有概念了，完全可以不看</p>
<h3 id="jQuery_Mobile即学即用">jQuery Mobile即学即用</h3><p>作者：Maximiliano Firtman</p>
<p>个人评分：★★★★</p>
<p><a href="https://github.com/LingyuCoder/Learn-jquery-mobile" target="_blank" rel="external">一些demo</a></p>
<p>介绍特定UI框架的一本书，就是告诉读者jQuery Mobile是什么、能干什么、怎么用，重要的是学习移动端Web的理念和模式。我还没有读完这本书，读了一半多，写了一些demo。确实使用它搭建移动端Web页面轻松写意加愉快（虽然估计有不少坑）</p>
<h3 id="Node_Web开发">Node Web开发</h3><p>作者：David Herron</p>
<p>个人评分：★★★</p>
<p>新手向的一本书，指导读者使用node搭建web server，并连接数据库。基本上就是node基础、web开发基础和express使用指南，外加一些可能会用到的库的介绍…翻译竟然是我之前实习所在的团队…</p>
<h3 id="图解CSS3：核心技术与案例实战">图解CSS3：核心技术与案例实战</h3><p>作者：大漠</p>
<p>个人评分：★★★</p>
<p>虽然这书好像挺火的，但是我读着很烦躁，因为读到的东西，文档上都有…基本上就是介绍各个CSS3属性是什么，怎么用，各个值效果是啥。适合新手阅读，或者在有某个属性不记得怎么用的时候，翻一翻…对于新手，全都是干货…</p>
<h3 id="神奇圣人：王阳明">神奇圣人：王阳明</h3><p>作者：雾满拦江</p>
<p>个人评分：★★★★</p>
<p>作者文笔俏皮活泼，以类似说书的方式将圣人阳明先生塑造成了一个欢脱的“顽童形象”，叙述了先生的一生，阅读起来很有意思。但全书主要介绍先生生平，对心学理论阐述较少，而且作者主观描述很多</p>
<h3 id="深入理解Bootstrap">深入理解Bootstrap</h3><p>作者：徐涛</p>
<p>个人评分：★★★★</p>
<p>汤姆大叔写的。详细介绍了Bootstrap 3.x各个模块如何使用、实现方法和架构理念，书中有很多带了注释的源码，对于有一定基础的读者，即便是没接触过Bootsrap读起来应该也不困难。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>上一篇文章是去年十一月，时隔两个多月了，这段时间由于毕业论文上屁事太多，没有静下心来写文章做总结。虽然学了不少新姿势，但是一直没在博客上做记录，特地写点东西来清清灰。</p>]]>
    
    </summary>
    
      <category term="生活" scheme="http://lingyu.wang/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="读书笔记" scheme="http://lingyu.wang/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[RisingStack的Node.js风格指南]]></title>
    <link href="http://lingyu.wang/2014/11/24/risingstack-nodejs-style-guide/"/>
    <id>http://lingyu.wang/2014/11/24/risingstack-nodejs-style-guide/</id>
    <published>2014-11-23T16:00:00.000Z</published>
    <updated>2015-05-31T15:00:49.000Z</updated>
    <content type="html"><![CDATA[<p>本文翻译自<a href="https://github.com/RisingStack/node-style-guide" target="_blank" rel="external">RisingStack/node-style-guide</a></p>
<a id="more"></a>
<h2 id="RisingStack_的Node-js_风格指南()_{"><a href="http://risingstack.com" target="_blank" rel="external">RisingStack</a> 的Node.js 风格指南() {</h2><h3 id="文章的大部分内容来自_Airbnb_stlyeguide">文章的大部分内容来自 <a href="https://github.com/airbnb/javascript" target="_blank" rel="external">Airbnb stlyeguide</a></h3><p>以下风格指南对此指南有很大影响:</p>
<ul>
<li>@caolan’s <a href="http://caolanmcmahon.com/posts/nodejs_style_and_structure" target="_blank" rel="external">Node.js stlyeguide</a></li>
<li>@felixge’s <a href="https://github.com/felixge/node-style-guide" target="_blank" rel="external">Node.js stlyeguide</a></li>
</ul>
<h2 id="类型">类型</h2><ul>
<li><p><strong>原生类型</strong>: 当访问一个原生类型时直接对其值进行操作</p>
<ul>
<li><code>string</code></li>
<li><code>number</code></li>
<li><code>boolean</code></li>
<li><code>null</code></li>
<li><code>undefined</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> bar = foo;</span><br><span class="line"></span><br><span class="line">bar = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo, bar); <span class="comment">// =&gt; 1, 9</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>复杂类型</strong>: 当访问一个复杂类型时，将对其值的引用上进行操作</p>
<ul>
<li><code>object</code></li>
<li><code>array</code></li>
<li><code>function</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> bar = foo;</span><br><span class="line"></span><br><span class="line">bar[<span class="number">0</span>] = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo[<span class="number">0</span>], bar[<span class="number">0</span>]); <span class="comment">// =&gt; 9, 9</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="对象">对象</h2><ul>
<li><p>使用字面量创建对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> item = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> item = &#123;&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用可读的同义单词来代替JavaScript的保留字</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 不推荐，class是保留字</span><br><span class="line">var superman = &#123;</span><br><span class="line">  class: 'alien'</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 不推荐，klass不具备可读性</span><br><span class="line">var superman = &#123;</span><br><span class="line">  klass: 'alien'</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 推荐</span><br><span class="line">var superman = &#123;</span><br><span class="line">  type: 'alien'</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="数组">数组</h2><ul>
<li><p>使用字面量创建数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> items = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> items = [];</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果不知道数组的长度，使用Array#push方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someStack = [];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line">someStack[someStack.length] = <span class="string">'abracadabra'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line">someStack.push(<span class="string">'abracadabra'</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用Array#slice来拷贝数组，这样性能较好，详见<a href="http://jsperf.com/converting-arguments-to-an-array/7" target="_blank" rel="external">jsPerf</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> len = items.length;</span><br><span class="line"><span class="keyword">var</span> itemsCopy = [];</span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐，遍历性能较低</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">  itemsCopy[i] = items[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line">itemsCopy = items.slice();</span><br></pre></td></tr></table></figure>
</li>
<li><p>将类数组对象转变为数组时，使用Array#slice方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trigger</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Strings">Strings</h2><ul>
<li><p>对字符串使用单引号<code>&#39;&#39;</code>包裹</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"Bob Parr"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Bob Parr'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> fullName = <span class="string">"Bob "</span> + <span class="keyword">this</span>.lastName;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> fullName = <span class="string">'Bob '</span> + <span class="keyword">this</span>.lastName;</span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串长度超过80个字符时，应当将字符串写成多行并通过加号进行拼接</p>
</li>
<li><p>注意：如果过度使用长字符串拼接方式将影响性能，详见<a href="http://jsperf.com/ya-string-concat" target="_blank" rel="external">jsPerf</a> &amp; <a href="https://github.com/airbnb/javascript/issues/40" target="_blank" rel="external">Discussion</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> errorMessage = <span class="string">'This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> errorMessage = <span class="string">'This is a super long error that was thrown because \</span><br><span class="line">of Batman. When you stop to think about how Batman had anything to do \</span><br><span class="line">with this, you would get nowhere \</span><br><span class="line">fast.'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> errorMessage = <span class="string">'This is a super long error that was thrown because '</span> +</span><br><span class="line">  <span class="string">'of Batman. When you stop to think about how Batman had anything to do '</span> +</span><br><span class="line">  <span class="string">'with this, you would get nowhere fast.'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当以编码的方式构建一个字符串时，使用Array#join方法，而不要拼接字符串</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> items;</span><br><span class="line"><span class="keyword">var</span> messages;</span><br><span class="line"><span class="keyword">var</span> length;</span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"></span><br><span class="line">messages = [&#123;</span><br><span class="line">  state: <span class="string">'success'</span>,</span><br><span class="line">  message: <span class="string">'This one worked.'</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">  state: <span class="string">'success'</span>,</span><br><span class="line">  message: <span class="string">'This one worked as well.'</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">  state: <span class="string">'error'</span>,</span><br><span class="line">  message: <span class="string">'This one did not work.'</span></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">length = messages.length;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inbox</span>(<span class="params">messages</span>) </span>&#123;</span><br><span class="line">  items = <span class="string">'&lt;ul&gt;'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    items += <span class="string">'&lt;li&gt;'</span> + messages[i].message + <span class="string">'&lt;/li&gt;'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> items + <span class="string">'&lt;/ul&gt;'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inbox</span>(<span class="params">messages</span>) </span>&#123;</span><br><span class="line">  items = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    items[i] = messages[i].message;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">'&lt;ul&gt;&lt;li&gt;'</span> + items.join(<span class="string">'&lt;/li&gt;&lt;li&gt;'</span>) + <span class="string">'&lt;/li&gt;&lt;/ul&gt;'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="函数">函数</h2><ul>
<li><p>函数表达式:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匿名函数表达式</span></span><br><span class="line"><span class="keyword">var</span> anonymous = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命名函数表达式</span></span><br><span class="line"><span class="keyword">var</span> named = <span class="function"><span class="keyword">function</span> <span class="title">named</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 立即执行函数 (immediately-invoked function expression, IIFE)</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Welcome to the Internet. Please follow me.'</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
</li>
<li><p>不要在非函数块（if、while等代码块）中声明函数，这种情况下应当将函数赋值给变量</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">if</span> (currentUser) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Nope.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> test;</span><br><span class="line"><span class="keyword">if</span> (currentUser) &#123;</span><br><span class="line">  test = <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Yup.'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不要声明<code>arguments</code>变量，这样将覆盖函数作用域的<code>arguments</code>对象（夺取了优先权，导致无法访问函数作用域的<code>arguments</code>）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nope</span>(<span class="params">name, options, arguments</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...stuff...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">yup</span>(<span class="params">name, options, args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...stuff...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="属性">属性</h2><ul>
<li><p>使用符号<code>.</code>来访问属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> luke = &#123;</span><br><span class="line">  jedi: <span class="literal">true</span>,</span><br><span class="line">  age: <span class="number">28</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> isJedi = luke[<span class="string">'jedi'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> isJedi = luke.jedi;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在需要通过变量访问属性时使用中括号<code>[]</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> luke = &#123;</span><br><span class="line">  jedi: <span class="literal">true</span>,</span><br><span class="line">  age: <span class="number">28</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProp</span>(<span class="params">prop</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> luke[prop];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isJedi = getProp(<span class="string">'jedi'</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="变量">变量</h2><ul>
<li><p>使用<code>var</code>来声明变量，这样能避免意外声明全局变量、污染全局命名空间。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line">superPower = <span class="keyword">new</span> SuperPower();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> superPower = <span class="keyword">new</span> SuperPower();</span><br></pre></td></tr></table></figure>
</li>
<li><p>每个变量声明新启一行，并在每个声明前面加上<code>var</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"> <span class="keyword">var</span> items = getItems(),</span><br><span class="line">      goSportsTeam = <span class="literal">true</span>,</span><br><span class="line">      dragonball = <span class="string">'z'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"> <span class="keyword">var</span> items = getItems();</span><br><span class="line"> <span class="keyword">var</span> goSportsTeam = <span class="literal">true</span>;</span><br><span class="line"> <span class="keyword">var</span> dragonball = <span class="string">'z'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>先声明需要赋值的变量，后声明不需要赋值的变量。这样后声明的变量能够依靠前面生成变量来生成自己的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"><span class="keyword">var</span> items = getItems(),</span><br><span class="line"><span class="keyword">var</span> dragonball,</span><br><span class="line"><span class="keyword">var</span> goSportsTeam = <span class="literal">true</span>,</span><br><span class="line"><span class="keyword">var</span> len;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> items = getItems(),</span><br><span class="line"><span class="keyword">var</span> goSportsTeam = <span class="literal">true</span>,</span><br><span class="line"><span class="keyword">var</span> dragonball,</span><br><span class="line"><span class="keyword">var</span> length,</span><br><span class="line"><span class="keyword">var</span> i;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在作用域的顶部声明所有变量，这样有助于避免变量提升导致的相关问题</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  test();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'doing stuff..'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//..other stuff..</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> name = getName();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (name === <span class="string">'test'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = getName();</span><br><span class="line"></span><br><span class="line">  test();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'doing stuff..'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//..other stuff..</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (name === <span class="string">'test'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = getName();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">arguments</span>.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">arguments</span>.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> name = getName();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="模块引用">模块引用</h2><ul>
<li><p>按照如下顺序引用模块</p>
<ul>
<li>核心模块</li>
<li>npm上的工具模块</li>
<li>其他模块</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> Car = <span class="built_in">require</span>(<span class="string">'./models/Car'</span>);</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">async</span> = <span class="built_in">require</span>(<span class="string">'async'</span>);</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">async</span> = <span class="built_in">require</span>(<span class="string">'async'</span>);</span><br><span class="line"><span class="keyword">var</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Car = <span class="built_in">require</span>(<span class="string">'./models/Car'</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>在模块引用时不要加上<code>.js</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> Batmobil = <span class="built_in">require</span>(<span class="string">'./models/Car.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> Batmobil = <span class="built_in">require</span>(<span class="string">'./models/Car'</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="回调函数">回调函数</h2><ul>
<li><p>总是在回调函数中检查是否出现错误</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不推荐</span></span><br><span class="line">database.get(<span class="string">'pokemons'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, pokemons</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(pokemons);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//推荐</span></span><br><span class="line">database.get(<span class="string">'drabonballs'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, drabonballs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="comment">// 通过某种方式处理错误，或者通过一个回调函数返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(drabonballs);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>回调函数也需要返回</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不推荐</span></span><br><span class="line">database.get(<span class="string">'drabonballs'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, drabonballs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="comment">// 如果不在这里返回</span></span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这一样依旧会执行</span></span><br><span class="line">  <span class="built_in">console</span>.log(drabonballs);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//推荐</span></span><br><span class="line">database.get(<span class="string">'drabonballs'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, drabonballs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="comment">// 通过某种方式处理错误，或者通过一个回调函数返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(drabonballs);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="异常捕获（Try-catch）">异常捕获（Try-catch）</h2><ul>
<li><p>只在同步函数中使用Try-catch</p>
<p>Try-catch代码块不能用来包裹异步的代码。Try-catch代码块将冒泡到最顶层，并记录整个冒泡的路径。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readPackageJson</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  fs.readFile(<span class="string">'package.json'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, file</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readPackageJson</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  fs.readFile(<span class="string">'package.json'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, file</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span>  callback(err);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在同步调用中使用Try-catch捕获异常</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不推荐</span></span><br><span class="line"><span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(jsonAsAString);</span><br><span class="line"></span><br><span class="line"><span class="comment">//推荐</span></span><br><span class="line"><span class="keyword">var</span> data;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  data = <span class="built_in">JSON</span>.parse(jsonAsAString);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// 处理错误 —— 最好不只是用console.log输出</span></span><br><span class="line">  <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="提升">提升</h2><ul>
<li><p>变量声明会提升到作用域顶端，但对这些变量的赋值是不会提升的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如我们所知，这不起作用 （没有同名的全局变量情况下）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(notDefined); <span class="comment">// =&gt; 抛出一个引用错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在引用一个变量之后创建一个变量声明一样能够正常工作</span></span><br><span class="line"><span class="comment">// 这是由于变量会提升。注意：这里赋值`true`并没有被提升</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(declaredButNotAssigned); <span class="comment">// =&gt; undefined</span></span><br><span class="line">  <span class="keyword">var</span> declaredButNotAssigned = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解释器会将变量声明提升到作用域的顶部</span></span><br><span class="line"><span class="comment">// 这也就意味着上例可以写成如下方式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> declaredButNotAssigned;</span><br><span class="line">  <span class="built_in">console</span>.log(declaredButNotAssigned); <span class="comment">// =&gt; undefined</span></span><br><span class="line">  declaredButNotAssigned = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>匿名函数表达式只会提升变量定义，函数赋值语句不会提升</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(anonymous); <span class="comment">// =&gt; undefined</span></span><br><span class="line"></span><br><span class="line">  anonymous(); <span class="comment">// =&gt; TypeError anonymous 不是函数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> anonymous = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'anonymous function expression'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>命名函数表达式同样提升变量定义，而不会提升函数名称和函数体</p>
</li>
<li><p>Named function expressions hoist the variable name, not the function name or the function body.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(named); <span class="comment">// =&gt; undefined</span></span><br><span class="line"></span><br><span class="line">  named(); <span class="comment">// =&gt; TypeError named 不是一个函数</span></span><br><span class="line"></span><br><span class="line">  superPower(); <span class="comment">// =&gt; ReferenceError superPower 未定义</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> named = <span class="function"><span class="keyword">function</span> <span class="title">superPower</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Flying'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 就算函数名称和变量名称相同，也是一样的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(named); <span class="comment">// =&gt; undefined</span></span><br><span class="line"></span><br><span class="line">  named(); <span class="comment">// =&gt; TypeError named 不是一个函数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> named = <span class="function"><span class="keyword">function</span> <span class="title">named</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'named'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数声明会提升名称和函数体</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  superPower(); <span class="comment">// =&gt; Flying</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">superPower</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Flying'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>更多信息可以查看 <a href="http://www.adequatelygood.com/2010/2/JavaScript-Scoping-and-Hoisting" target="_blank" rel="external">JavaScript Scoping &amp; Hoisting</a> ，作者为 <a href="http://www.adequatelygood.com/" target="_blank" rel="external">Ben Cherry</a></p>
</li>
</ul>
<h2 id="条件表达式和相等判断">条件表达式和相等判断</h2><ul>
<li>使用 <code>===</code> 和 <code>!==</code> ，不要用 <code>==</code> 和 <code>!=</code></li>
<li><p>条件表达式计算时会强迫使用<code>ToBoolean</code>方法，并遵循如下规则：</p>
<ul>
<li><strong>Objects</strong> 判定为 <strong>true</strong></li>
<li><strong>Undefined</strong> 判定为 <strong>false</strong></li>
<li><strong>Null</strong> 判定为 <strong>false</strong></li>
<li><strong>Booleans</strong> 判定为 <strong>the value of the boolean</strong></li>
<li><strong>Numbers</strong> 如果为 <strong>+0, -0, or NaN</strong> 判定为 <strong>false</strong>，否则为 <strong>true</strong></li>
<li><strong>Strings</strong> 如果为 空字符串 <code>&#39;&#39;</code> 判定为 <strong>false</strong> 否则为 <strong>true</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([<span class="number">0</span>]) &#123;</span><br><span class="line">  <span class="comment">// true</span></span><br><span class="line">  <span class="comment">// 数组也是对象，对象都判定为true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>善于简写</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">if</span> (name !== <span class="string">''</span>) &#123;</span><br><span class="line">  <span class="comment">// ...stuff...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">if</span> (name) &#123;</span><br><span class="line">  <span class="comment">// ...stuff...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">if</span> (collection.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// ...stuff...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">if</span> (collection.length) &#123;</span><br><span class="line">  <span class="comment">// ...stuff...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>更多信息请查看Angus Croll所著的 <a href="http://javascriptweblog.wordpress.com/2011/02/07/truth-equality-and-javascript/#more-2108" target="_blank" rel="external">Truth Equality and JavaScript</a> </p>
</li>
</ul>
<h2 id="代码块">代码块</h2><ul>
<li>在所有多行代码块时都是用大括号</li>
<li><p>Use braces with all multi-line blocks.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">if</span> (test)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">if</span> (test) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">if</span> (test) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="注释">注释</h2><ul>
<li><p>使用<code>/**....*/</code>包裹多行注释，这种注释包括描述、参数及返回值的类型和值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="comment">// make() returns a new element</span></span><br><span class="line"><span class="comment">// based on the passed in tag name</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// @param &lt;String&gt; tag</span></span><br><span class="line"><span class="comment">// @return &lt;Element&gt; element</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">make</span>(<span class="params">tag</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...stuff...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * make() returns a new element</span><br><span class="line"> * based on the passed in tag name</span><br><span class="line"> *</span><br><span class="line"> * @param &lt;String&gt; tag</span><br><span class="line"> * @return &lt;Element&gt; element</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">make</span>(<span class="params">tag</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...stuff...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>单行注释时使用<code>//</code>。每一个单行注释在需要注释的位置上面新启一行。并在注释前加一个空行</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> active = <span class="literal">true</span>;  <span class="comment">// is current tab</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="comment">// is current tab</span></span><br><span class="line"><span class="keyword">var</span> active = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'fetching type...'</span>);</span><br><span class="line">  <span class="comment">// 设定默认值为'no type'</span></span><br><span class="line">  <span class="keyword">var</span> type = <span class="keyword">this</span>._type || <span class="string">'no type'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'fetching type...'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设定默认值为'no type'</span></span><br><span class="line">  <span class="keyword">var</span> type = <span class="keyword">this</span>._type || <span class="string">'no type'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在注释前增加<code>FIXME</code>或<code>TODO</code>来帮助其他开发者快速理解这里出现了一个问题或是需要提供实现。这种注释和常规的注释不同，它是可操作的。这些操作为<code>FIXME -- 需要弄清楚</code>或是<code>TODO -- 需要添加实现</code></p>
</li>
<li><p>使用 <code>// FIXME:</code> 来标注问题</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Calculator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag"><span class="keyword">FIXME</span></span>: 这里不应该有全局变量</span></span><br><span class="line">  total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>// TODO:</code> 来标注问题的解法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Calculator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag"><span class="keyword">TODO</span></span>: total应该通过参数来配置</span></span><br><span class="line">  <span class="keyword">this</span>.total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="空格">空格</h2><ul>
<li><p>将TAB设置成两个空格</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">∙∙∙∙<span class="keyword">var</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">∙<span class="keyword">var</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">∙∙<span class="keyword">var</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在大括号前加个空格</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line">dog.set(<span class="string">'attr'</span>,&#123;</span><br><span class="line">  age: <span class="string">'1 year'</span>,</span><br><span class="line">  breed: <span class="string">'Bernese Mountain Dog'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line">dog.set(<span class="string">'attr'</span>, &#123;</span><br><span class="line">  age: <span class="string">'1 year'</span>,</span><br><span class="line">  breed: <span class="string">'Bernese Mountain Dog'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>在操作符旁边加上空格</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> x=y+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> x = y + <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>以一个换行符结束文件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">global</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...stuff...</span></span><br><span class="line">&#125;)(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">global</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...stuff...</span></span><br><span class="line">&#125;)(<span class="keyword">this</span>);↵</span><br><span class="line">↵</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">global</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...stuff...</span></span><br><span class="line">&#125;)(<span class="keyword">this</span>);↵</span><br></pre></td></tr></table></figure>
</li>
<li></li>
<li><p>为长的链式方法调用增加缩进</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line">$(<span class="string">'#items'</span>).find(<span class="string">'.selected'</span>).highlight().end().find(<span class="string">'.open'</span>).updateCount();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line">$(<span class="string">'#items'</span>)</span><br><span class="line">  .find(<span class="string">'.selected'</span>)</span><br><span class="line">    .highlight()</span><br><span class="line">    .end()</span><br><span class="line">  .find(<span class="string">'.open'</span>)</span><br><span class="line">    .updateCount();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> leds = stage.selectAll(<span class="string">'.led'</span>).data(data).enter().append(<span class="string">'svg:svg'</span>).class(<span class="string">'led'</span>, <span class="literal">true</span>)</span><br><span class="line">    .attr(<span class="string">'width'</span>,  (radius + margin) * <span class="number">2</span>).append(<span class="string">'svg:g'</span>)</span><br><span class="line">    .attr(<span class="string">'transform'</span>, <span class="string">'translate('</span> + (radius + margin) + <span class="string">','</span> + (radius + margin) + <span class="string">')'</span>)</span><br><span class="line">    .call(tron.led);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> leds = stage.selectAll(<span class="string">'.led'</span>)</span><br><span class="line">    .data(data)</span><br><span class="line">  .enter().append(<span class="string">'svg:svg'</span>)</span><br><span class="line">    .class(<span class="string">'led'</span>, <span class="literal">true</span>)</span><br><span class="line">    .attr(<span class="string">'width'</span>,  (radius + margin) * <span class="number">2</span>)</span><br><span class="line">  .append(<span class="string">'svg:g'</span>)</span><br><span class="line">    .attr(<span class="string">'transform'</span>, <span class="string">'translate('</span> + (radius + margin) + <span class="string">','</span> + (radius + margin) + <span class="string">')'</span>)</span><br><span class="line">    .call(tron.led);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="逗号">逗号</h2><ul>
<li><p>以逗号启始: <strong>不</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> hero = &#123;</span><br><span class="line">    firstName: <span class="string">'Bob'</span></span><br><span class="line">  , lastName: <span class="string">'Parr'</span></span><br><span class="line">  , heroName: <span class="string">'Mr. Incredible'</span></span><br><span class="line">  , superPower: <span class="string">'strength'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> hero = &#123;</span><br><span class="line">  firstName: <span class="string">'Bob'</span>,</span><br><span class="line">  lastName: <span class="string">'Parr'</span>,</span><br><span class="line">  heroName: <span class="string">'Mr. Incredible'</span>,</span><br><span class="line">  superPower: <span class="string">'strength'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在结尾加上逗号：<em>不</em>。这将在IE6/7和IE9的怪异模式中引发一些问题。而且，如果在数组中这么做，在一些ES3的实现中会增加数组的长度。这在ES5中做了修正(<a href="http://es5.github.io/#D" target="_blank" rel="external">source</a>)：</p>
<blockquote>
<p>Edition 5 clarifies the fact that a trailing comma at the end of an ArrayInitialiser does not add to the length of the array. This is not a semantic change from Edition 3 but some implementations may have previously misinterpreted this.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> hero = &#123;</span><br><span class="line">  firstName: <span class="string">'Kevin'</span>,</span><br><span class="line">  lastName: <span class="string">'Flynn'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> heroes = [</span><br><span class="line">  <span class="string">'Batman'</span>,</span><br><span class="line">  <span class="string">'Superman'</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> hero = &#123;</span><br><span class="line">  firstName: <span class="string">'Kevin'</span>,</span><br><span class="line">  lastName: <span class="string">'Flynn'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> heroes = [</span><br><span class="line">  <span class="string">'Batman'</span>,</span><br><span class="line">  <span class="string">'Superman'</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="分号">分号</h2><ul>
<li><p>永远使用分号</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'Skywalker'</span></span><br><span class="line">  <span class="keyword">return</span> name</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'Skywalker'</span>;</span><br><span class="line">  <span class="keyword">return</span> name;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'Skywalker'</span>;</span><br><span class="line">  <span class="keyword">return</span> name;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="类型转换和强制类型转换">类型转换和强制类型转换</h2><ul>
<li>在声明开头进行强制类型转换</li>
<li><p>字符串:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  =&gt; this.reviewScore = 9;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> totalScore = <span class="keyword">this</span>.reviewScore + <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> totalScore = <span class="string">''</span> + <span class="keyword">this</span>.reviewScore;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> totalScore = <span class="string">''</span> + <span class="keyword">this</span>.reviewScore + <span class="string">' total score'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> totalScore = <span class="keyword">this</span>.reviewScore + <span class="string">' total score'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>parseInt</code> 转换成数字并总是加上进制数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inputValue = <span class="string">'4'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> val = <span class="keyword">new</span> <span class="built_in">Number</span>(inputValue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> val = +inputValue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> val = inputValue &gt;&gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> val = <span class="built_in">parseInt</span>(inputValue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> val = <span class="built_in">Number</span>(inputValue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> val = <span class="built_in">parseInt</span>(inputValue, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果你出于某种原因做一些非常规的需求且<code>parseInt</code>是你性能的瓶颈，必须用位操作<a href="http://jsperf.com/coercion-vs-casting/3" target="_blank" rel="external">提升性能</a>时，添加注释来解释为什么这么做、到底做了什么。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * parseInt是性能不佳的原因</span><br><span class="line"> * 位操作强制将一个String转换为Number要快得多</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">var</span> val = inputValue &gt;&gt; <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>注意:</strong> 使用位操作时需要注意。所有的数字都是<a href="http://es5.github.io/#x4.3.19" target="_blank" rel="external">64位浮点型</a>，但位操作经常返回32位整型（<a href="http://es5.github.io/#x11.7" target="_blank" rel="external">请看</a>）。位操作会在值大于32位时发生一些问题。<a href="https://github.com/airbnb/javascript/issues/109" target="_blank" rel="external">这里有一些关于此的讨论</a>。最大的有符号整型是 2,147,483,647</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2147483647</span> &gt;&gt; <span class="number">0</span> <span class="comment">//=&gt; 2147483647</span></span><br><span class="line"><span class="number">2147483648</span> &gt;&gt; <span class="number">0</span> <span class="comment">//=&gt; -2147483648</span></span><br><span class="line"><span class="number">2147483649</span> &gt;&gt; <span class="number">0</span> <span class="comment">//=&gt; -2147483647</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>布尔类型:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> hasAge = <span class="keyword">new</span> <span class="built_in">Boolean</span>(age);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> hasAge = <span class="built_in">Boolean</span>(age);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> hasAge = !!age;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="命名约定">命名约定</h2><ul>
<li><p>避免单字母的命名。命名应该能够自解释</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">q</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...stuff...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">query</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ..stuff..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在命名对象、函数和实例的时候使用驼峰命名法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> OBJEcttsssss = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> this_is_my_object = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> u = <span class="keyword">new</span> user(&#123;</span><br><span class="line">  name: <span class="string">'Bob Parr'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> thisIsMyObject = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">thisIsMyFunction</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> User(&#123;</span><br><span class="line">  name: <span class="string">'Bob Parr'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>在命名构造函数和类时使用帕斯卡构造法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">user</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = options.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bad = <span class="keyword">new</span> user(&#123;</span><br><span class="line">  name: <span class="string">'nope'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = options.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> good = <span class="keyword">new</span> User(&#123;</span><br><span class="line">  name: <span class="string">'yup'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>命名私有属性时添加<code>_</code>前缀</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">this</span>.__firstName__ = <span class="string">'Panda'</span>;</span><br><span class="line"><span class="keyword">this</span>.firstName_ = <span class="string">'Panda'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">this</span>._firstName = <span class="string">'Panda'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当需要保存一个<code>this</code>的引用时，使用<code>_this</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(self);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(that);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(_this);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>总是为函数命名，这样有助于栈的追踪</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> log = <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(msg);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> log = <span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(msg);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="访问器">访问器</h2><ul>
<li>一般不需要属性的访问器函数</li>
<li><p>如果要创造属性的访问器函数，使用 getVal() 和 setVal(‘hello’)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line">dragon.age();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line">dragon.getAge();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line">dragon.age(<span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line">dragon.setAge(<span class="number">25</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果属性时布尔类型，使用 isVal() 或 hasVal()</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">if</span> (!dragon.age()) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">if</span> (!dragon.hasAge()) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以创建 get() 和 set() 方法，但必须一致</p>
</li>
<li><p>It’s okay to create get() and set() functions, but be consistent.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Jedi</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  options || (options = &#123;&#125;);</span><br><span class="line">  <span class="keyword">var</span> lightsaber = options.lightsaber || <span class="string">'blue'</span>;</span><br><span class="line">  <span class="keyword">this</span>.set(<span class="string">'lightsaber'</span>, lightsaber);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Jedi.prototype.set = <span class="function"><span class="keyword">function</span>(<span class="params">key, val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>[key] = val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Jedi.prototype.get = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>[key];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="构造函数">构造函数</h2><ul>
<li><p>给构造函数的prototype对象增加新方法，不要直接给prototype重写一个新的对象。重写prototype对象会导致无法继承：重写prototype将覆盖掉基类。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Jedi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'new jedi'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line">Jedi.prototype = &#123;</span><br><span class="line">  fight: <span class="function"><span class="keyword">function</span> <span class="title">fight</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fighting'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  block: <span class="function"><span class="keyword">function</span> <span class="title">block</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'blocking'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line">Jedi.prototype.fight = <span class="function"><span class="keyword">function</span> <span class="title">fight</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'fighting'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Jedi.prototype.block = <span class="function"><span class="keyword">function</span> <span class="title">block</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'blocking'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以为方法返回<code>this</code>方便链式调用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line">Jedi.prototype.jump = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.jumping = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Jedi.prototype.setHeight = <span class="function"><span class="keyword">function</span>(<span class="params">height</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.height = height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> luke = <span class="keyword">new</span> Jedi();</span><br><span class="line">luke.jump(); <span class="comment">// =&gt; true</span></span><br><span class="line">luke.setHeight(<span class="number">20</span>) <span class="comment">// =&gt; undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line">Jedi.prototype.jump = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.jumping = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Jedi.prototype.setHeight = <span class="function"><span class="keyword">function</span>(<span class="params">height</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.height = height;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> luke = <span class="keyword">new</span> Jedi();</span><br><span class="line"></span><br><span class="line">luke.jump()</span><br><span class="line">  .setHeight(<span class="number">20</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以重写toString()方法，只要它能正常工作且不会有副作用就行</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Jedi</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  options || (options = &#123;&#125;);</span><br><span class="line">  <span class="keyword">this</span>.name = options.name || <span class="string">'no name'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Jedi.prototype.getName = <span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Jedi.prototype.toString = <span class="function"><span class="keyword">function</span> <span class="title">toString</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'Jedi - '</span> + <span class="keyword">this</span>.getName();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>推荐的书籍</strong></p>
<ul>
<li><a href="http://www.amazon.com/JavaScript-Good-Parts-Douglas-Crockford/dp/0596517742" target="_blank" rel="external">JavaScript语言精粹</a> - Douglas Crockford</li>
<li><a href="http://www.amazon.com/JavaScript-Patterns-Stoyan-Stefanov/dp/0596806752" target="_blank" rel="external">JavaScript模式</a> - Stoyan Stefanov</li>
<li><a href="http://www.amazon.com/JavaScript-Design-Patterns-Recipes-Problem-Solution/dp/159059908X" target="_blank" rel="external">JavaScript设计模式</a>  - Ross Harmes and Dustin Diaz</li>
<li><a href="http://www.amazon.com/High-Performance-Web-Sites-Essential/dp/0596529309" target="_blank" rel="external">高性能网站建设指南</a> - Steve Souders</li>
<li><a href="http://www.amazon.com/Maintainable-JavaScript-Nicholas-C-Zakas/dp/1449327680" target="_blank" rel="external">编写可维护的JavaScript</a> - Nicholas C. Zakas</li>
<li><a href="http://www.amazon.com/JavaScript-Web-Applications-Alex-MacCaw/dp/144930351X" target="_blank" rel="external">JavaScript Web 富应用开发</a> - Alex MacCaw</li>
<li><a href="http://www.amazon.com/Pro-JavaScript-Techniques-John-Resig/dp/1590597273" target="_blank" rel="external">Pro JavaScript Techniques</a> - John Resig</li>
<li><a href="http://www.amazon.com/Smashing-Node-js-JavaScript-Everywhere-Magazine/dp/1119962595" target="_blank" rel="external">Smashing Node.js: JavaScript Everywhere</a> - Guillermo Rauch</li>
<li><a href="http://www.amazon.com/Secrets-JavaScript-Ninja-John-Resig/dp/193398869X" target="_blank" rel="external">Secrets of the JavaScript Ninja</a> - John Resig and Bear Bibeault</li>
<li><a href="http://humanjavascript.com/" target="_blank" rel="external">Human JavaScript</a> - Henrik Joreteg</li>
<li><a href="http://superherojs.com/" target="_blank" rel="external">Superhero.js</a> - Kim Joar Bekkelund, Mads Mobæk, &amp; Olav Bjorkoy</li>
<li><a href="http://jsbooks.revolunet.com/" target="_blank" rel="external">JSBooks</a></li>
<li><a href="http://manning.com/vinegar/" target="_blank" rel="external">Third Party JavaScript</a> - Ben Vinegar and Anton Kovalyov</li>
</ul>
<p><strong>推荐的博客</strong></p>
<ul>
<li><a href="http://dailyjs.com/" target="_blank" rel="external">DailyJS</a></li>
<li><a href="http://javascriptweekly.com/" target="_blank" rel="external">JavaScript Weekly</a></li>
<li><a href="http://javascriptweblog.wordpress.com/" target="_blank" rel="external">JavaScript, JavaScript…</a></li>
<li><a href="http://weblog.bocoup.com/" target="_blank" rel="external">Bocoup Weblog</a></li>
<li><a href="http://www.adequatelygood.com/" target="_blank" rel="external">Adequately Good</a></li>
<li><a href="http://www.nczonline.net/" target="_blank" rel="external">NCZOnline</a></li>
<li><a href="http://perfectionkills.com/" target="_blank" rel="external">Perfection Kills</a></li>
<li><a href="http://benalman.com/" target="_blank" rel="external">Ben Alman</a></li>
<li><a href="http://dmitry.baranovskiy.com/" target="_blank" rel="external">Dmitry Baranovskiy</a></li>
<li><a href="http://dustindiaz.com/" target="_blank" rel="external">Dustin Diaz</a></li>
<li><a href="http://net.tutsplus.com/?s=javascript" target="_blank" rel="external">nettuts</a></li>
</ul>
<h2 id="JavaScript风格指南">JavaScript风格指南</h2><ul>
<li><a href="https://github.com/airbnb/javascript/wiki/The-JavaScript-Style-Guide-Guide" target="_blank" rel="external">查看</a></li>
</ul>
<h2 id="项目贡献者">项目贡献者</h2><ul>
<li><a href="https://github.com/airbnb/javascript/graphs/contributors" target="_blank" rel="external">查看贡献者</a></li>
</ul>
<h2 id="License">License</h2><p>MIT</p>
<h1 id="};">};</h1>]]></content>
    <summary type="html">
    <![CDATA[<p>本文翻译自<a href="https://github.com/RisingStack/node-style-guide">RisingStack/node-style-guide</a></p>]]>
    
    </summary>
    
      <category term="NodeJs" scheme="http://lingyu.wang/tags/NodeJs/"/>
    
      <category term="翻译" scheme="http://lingyu.wang/categories/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[构建华丽UI的7条准则（上部）]]></title>
    <link href="http://lingyu.wang/2014/11/24/7-rules-for-creating-gorgeous-ui-part-1/"/>
    <id>http://lingyu.wang/2014/11/24/7-rules-for-creating-gorgeous-ui-part-1/</id>
    <published>2014-11-23T16:00:00.000Z</published>
    <updated>2015-05-31T15:00:49.000Z</updated>
    <content type="html"><![CDATA[<p>本文翻译自Erik D. Kennedy的<a href="https://medium.com/@erikdkennedy/7-rules-for-creating-gorgeous-ui-part-1-559d4e805cda?hn=1" target="_blank" rel="external">7 Rules for Creating Gorgeous UI (Part 1)</a></p>
<a id="more"></a>
<h2 id="简介">简介</h2><p>好吧，首先需要说明的是，这篇指南并不适合每一个人。那么它适合哪些人呢？</p>
<ul>
<li>那些要在紧要关头设计他们自己的好看的UI的<strong>开发者</strong></li>
<li>那些希望自己的作品集看起来比五边形PPT更炫酷或是那些将优秀的用户体验和漂亮的UI打包出售的<strong>用户体验（以下简称UX）设计师</strong></li>
</ul>
<p>如果你曾经上过艺术学校，或是认为自己已经是一个UI设计师，你很可能会觉着这篇指南充斥着a.) 无聊, b.) 错误, and c.) 不爽。没关系。你的所有批评都是对的。关掉页面，该干啥干啥。</p>
<p>让我来告诉你这篇指南里都有些什么。</p>
<p>首先，我是一个没有UI技能的UX设计师。我喜欢设计用户体验，但<br>我干的时间不长，直到我了解到如下这些驱动我去学界面美化的原因：</p>
<ul>
<li>我的作品集看起来很废，无法很好的反映我的工作和思想进程；</li>
<li>我的UX咨询客户更愿意去找那些不只会画方框和箭头，而懂得更多专业知识的人；</li>
<li>我是否在某些时候需要在项目初期干活？不只是帮忙扫扫地</li>
</ul>
<p>我有我自己的理由。我并不了解垃圾美学观。我是个做工程的，而最令我自豪的就是构建一些帅气的东西。</p>
<p>最后，我学到了应用程序的每学，它和任何其他创造性的活动中的一样：冰冷，难以分析。以及无耻的从他人作品中模仿。我曾在一个UI项目上花费了10个小时，但只赚了一个小时的钱。其他的9个小时都是在瞎逛式的学习。无休止的搜索Google、Pinterest和Dribbble来找可以模仿的作品。</p>
<p>这些准则就是这样总结出来的</p>
<p><strong>所以有一些话希望告诉那些书呆子们：如果做出了优秀的设计，并不是因为我参透了美感和平衡，而是因为我分析出了成果。</strong></p>
<p>这篇文章并不是一些理论，都是纯粹的应用。你不会看到任何和黄金分割相关的东西。我甚至都没有提及色彩理论。只有那些我不断失败不断练习所学到的东西。</p>
<p>可以这样说：柔道是基于几个世纪的日本无数和哲学传统发展而来的。你参与了柔道训练，并进行了实战，你就会听到很多关于能量、流动、平和以及之类的东西。</p>
<p>另一方面，马伽术是一些在20世纪30年代捷克斯洛伐克的一些强硬的犹太人，为了在街头对抗纳粹所发明的。其中没有任何艺术科研，在它的课程中，你学到的是如何通过一支笔去刺瞎别人的眼镜。</p>
<p>这里就是屏幕上的马伽术</p>
<p>这些准则包括：</p>
<ol>
<li>光来自天空</li>
<li>黑白先行</li>
<li>使用双倍的留白</li>
<li>学习如何在图像上叠加文字</li>
<li>让文字弹出——并且反流行</li>
<li>仅使用好的字体</li>
<li>像艺术家一样去偷</li>
</ol>
<p>让我们开始吧</p>
<h2 id="准则一：光来自天空">准则一：光来自天空</h2><p><em>阴影是用来帮助大脑用来分辨用户界面上元素的宝贵线索</em></p>
<p>这可能是在学习UI设计中<strong>最重要且常被忽略</strong>的了：光来自天空。光线时常来自于天空，如果从下方来的话会看起来很怪异。</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-11-24/1.jpeg" alt="wooooo"></p>
<p>当光线来自天空，它照亮了物体的顶部并在他们下方留下阴影。物体的顶部更亮，底部更暗。</p>
<p>你不会把人的下眼睑当做特别的阴影，但当光照在上面时，瞬间就好像一个妖娆的女孩站在你的门前。</p>
<p>是的，UI也是一样。正如我们的所有五官下侧都会有较小的阴影，在我们所看到的每个UI元素下面也有阴影。<strong>屏幕是扁平的，但我们已经找到了很多方法使得他们看起来像是3D的</strong></p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-11-24/2.png" alt="My favorite part of this image is the poker finger in the lower-right."></p>
<p>就拿按钮来说。即使这种相对“扁平”的按钮，它仍有一些与光线相关的细节：</p>
<ol>
<li>未按下的按钮（上图）有一个较暗的底部边缘。太阳光照不到那里；</li>
<li>未按下的按钮的<strong>顶部比底部稍微亮一些</strong>。这是因为它模拟了一个稍微弯曲的表面。就和你需要倾斜你面前的镜子才能看到里面的太阳一样，倾斜向上的表面对你反射了的太阳光多了那么一点点；</li>
<li>未按下的按钮蒙上了<strong>细微的阴影</strong>，可能你将部分进行放大才能看见</li>
<li>按下的按钮，底部依然要比顶部更暗，但它<strong>整体都变暗了</strong>——这是因为它在屏幕同意平面上，而光不再那么容易地照到它。可能有人会说了，现实生活中我们按下的按钮颜色也会较深，事实上那是因为我们的双手遮挡住了光线。</li>
</ol>
<p>这只是一个按钮，但也呈现出4个小的光线效果。那么问题来了，我们需要将这些运用到所有元素下。</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-11-24/3.png" alt="iOS 6 is a little outdated, but it makes a good case study in light behavior."></p>
<p>这是iOS 6的“请勿打扰”和“通知”的设定。很漂亮不是吗？那么我们来看看它有多少光线效果。</p>
<ul>
<li>面板的顶部上有细小的阴影</li>
<li>“ON”开关的滑动轨道上也有</li>
<li>“ON”开关的滑动轨道是凹陷的，而底部反射更多的光</li>
<li>图标突出了一点，是否看到它顶部的边框更亮？这代表了一个垂直于光源的面，因此接收到了不少的光，也因此反射更多光到你眼睛</li>
<li>面板分割的缺口远离阳光的角度蒙有阴影，反之亦然</li>
</ul>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-11-24/4.png" alt="A close-up of a divider notch. From an old Hubster concept of mine."></p>
<p>以下元素通常看起来是<strong>内嵌</strong>的：</p>
<ul>
<li>文本输入框</li>
<li>按下的按钮</li>
<li>开关的滑动轨道</li>
<li>单选按钮（未被选择）（radio）</li>
<li>复选按钮（checkbox）</li>
</ul>
<p>以下元素通常看起来是<strong>外凸</strong>的：</p>
<ul>
<li>按钮（未按下）</li>
<li>开关</li>
<li>下拉控件</li>
<li>卡片</li>
<li>被选择的单选按钮的按钮部分</li>
<li>弹出窗口</li>
</ul>
<p>现在你学到了，你会发现到处都是这样。欢迎你，孩子</p>
<h3 id="等等，扁平化设计怎么办呢，Erik？">等等，扁平化设计怎么办呢，Erik？</h3><p>iOS7的“扁平化设计”轰动了技术社区。如字面上所说，它是平的。没有凸起或凹陷，只是纯色的线条和形状。</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-11-24/5.png" alt="iOS 7 扁平设计"></p>
<p>我和后面那个家伙一样喜欢干净和简洁，但我不认为这是个长期的趋势。我们在界面上对于3D的模拟，还远远没有自然到能够放弃一切。</p>
<p><strong>很有可能在不久的将来我们就会见到半扁平UI</strong>（我推荐你能够精通这样的设计）。进一步可以称之为“扁平化的设计（flatty design）”。依然干净，依然简洁，但那些需要触碰、滑动、点击的元素会有一些阴影和线索。</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-11-24/6.png" alt="OS X Yosemite—不只是扁平，而是扁平化"></p>
<p>在我写这篇文章时，Google在他们的产品之上推出了“Material Design”语言。这是一个统一的视觉语言，它的核心思想就旨在模仿现实世界。</p>
<p>从Material Design的设计图中可以看出，它展示了如何通过不同的阴影来表现元素不同的深度。</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-11-24/7.png" alt="Material Design 1"></p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-11-24/8.png" alt="Material Design 2"></p>
<p>这是我一直坚持做的事情。</p>
<p>它采用了细微的现实世界的线索来传达信息。<strong>关键字，细微</strong>。</p>
<p>你不能说它没有模仿现实世界，但也没有像2006年的网站上那样的纹理、渐变和光亮。</p>
<p>我认为扁平化是未来。扁平？那只是过去。</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-11-24/9.png" alt="扁平设计现在似乎大热"></p>
<h2 id="规则二——黑白先行">规则二——黑白先行</h2><p><em>在添加颜色之前使用灰度进行设计能让最复杂元素的视觉设计也变得简单。</em></p>
<p>如今UX设计师也进行“移动先行”的设计。这就意味着，先在手机上考虑页面样式及交互，然后再扩展到高像素的Retina屏幕上</p>
<p><strong>这是个非常好的约束。它传达了一个思想。</strong>先从困难的问题开始（在较小的屏幕上可用的应用程序），然后将解决方案适配到简单的问题上（在大屏幕上可用的应用程序）。</p>
<p>还有一个类似的约束：先用黑白进行设计。在没有颜色的帮助下，以让应用在各个角度下漂亮且可用这样的困难问题作为开始。最后再添加颜色，即使如此，明确目标。</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-11-24/10.png" alt="Haraldur Thorleifsson’s grayscale wireframes look as good as lesser designer’s finished sites."></p>
<p>这是一个保持应用程序看起来“简洁”的较为可靠且简单的方式。<strong>过多的颜色很容易破坏“简洁”。</strong>黑白先行使得你更加专注于留白、尺寸和布局。而这些正式“简洁”设计所关注的。</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-11-24/11.png" alt="Classy grayscale."><br><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-11-24/12.jpeg" alt="Classy grayscale."><br><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-11-24/13.png" alt="Classy grayscale."></p>
<p>在某些情况下黑白先行并没有效果。那些有很强特定风格的设计——“运动的”、“浮华的”、“卡通的”，等等——需要设计师非常好的使用颜色。但<strong>大多数应用程序除了“简洁”以外都没有特定的风格。</strong>不可否认，那些设计更难。</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-11-24/14.png" alt="Flashy and vibrant designs by Julien Renvoye (left) and Cosmin Capitanu (right). Harder than it looks."></p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-11-24/15.png" alt="Flashy and vibrant designs by Julien Renvoye (left) and Cosmin Capitanu (right). Harder than it looks."></p>
<p>对于其他的，都可以用黑白先行</p>
<h3 id="第二步：如何上色">第二步：如何上色</h3><p>最简单的上色方式就是只添加一种颜色</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-11-24/16.png" alt="添加一种颜色"></p>
<p>往黑白的网页中添加一种颜色是简单而有效地吸引眼球方式</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-11-24/17.png" alt="添加一种颜色"></p>
<p>你也可以更进一步，灰度+两种颜色，或是灰度+单一色调的多种颜色</p>
<blockquote>
<p><strong>实践中的色码——等等，什么事色调？</strong></p>
<p>网页和大多数人都是用16进制RGB编码表示颜色。最好忽略这些。RGB并不是一个好的颜色设计框架。<a href="http://demosthenes.info/blog/61/An-Easy-Guide-To-HSL-Color-In-CSS3" target="_blank" rel="external">HSB</a>更有用（HSB与HSV或HSL“基本上是同义的”）</p>
<p>HSB比RGB更好，以为它符合我们自然思考颜色的方式，你能从HSB值的改变中预测到颜色的变化。</p>
<p>如果这对你来说是个新闻，这里有一个对于<a href="http://demosthenes.info/blog/61/An-Easy-Guide-To-HSL-Color-In-CSS3" target="_blank" rel="external">HSB颜色的介绍</a>。</p>
</blockquote>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-11-24/18.jpeg" alt="来自Smashing Magazine的单色调的金色主题"></p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-11-24/19.jpeg" alt="来自Smashing Magazine的单色调的蓝色主题"></p>
<p>通过修改单一色相的<strong>饱和度</strong>和<strong>亮度</strong>，可以生成更多的颜色——深色的、浅色的、当背景的、做强调的、吸引眼球的——但它并不会在你眼前压倒一切。</p>
<p>使用来自一种或两种色相的多个颜色是在<strong>不破坏设计的前提下突出和弱化元素的最可靠的方法。</strong></p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-11-24/20.png" alt="Countdown timer by Kerem Suer"></p>
<h2 id="颜色使用的一些其他的注意事项">颜色使用的一些其他的注意事项</h2><p>颜色是视觉设计中最复杂的部分。虽然颜色上的很多东西并不精细，而且对于你面前的设计并不适用，我还是看到了一些不错的东西：</p>
<p>一些小工具：</p>
<ul>
<li><a href="http://ianstormtaylor.com/design-tip-never-use-black/" target="_blank" rel="external">永远不要使用纯黑</a> (Ian Storm Taylor)。这篇文章中说，纯粹的灰色几乎不会出现在现实世界，灰色的色调的饱和度——尤其是较暗的色调——能为你的设计添加丰富的视觉效果。此外，饱和的灰色更好的模拟了现实世界，这正是它的美之所在。</li>
<li><a href="https://color.adobe.com/" target="_blank" rel="external">Adobe Color CC</a>.一个用来发现、修改和创建颜色方案的优秀工具</li>
<li><a href="https://dribbble.com/colors/BADA55" target="_blank" rel="external">通过颜色搜索Dribbble</a>. 另外一个找到某一个特定颜色实践的不错方式。这很实用。如果你已经决定使用某个颜色，看看世界上最好的设计师们如何使用这个颜色。</li>
</ul>
<h2 id="规则三：使用双倍的留白">规则三：使用双倍的留白</h2><p><em>增加更多呼吸空间可以让你的UI看起来有设计感</em></p>
<p>我曾在规则二中说过，“黑白先行”迫使设计师在考虑配色之前先考虑留白和布局，以及这为什么好。那么，现在来聊聊留白和布局。</p>
<p>如果你曾在<a href="http://baike.baidu.com/subview/526745/15420063.htm" target="_blank" rel="external">scratch</a>（一款面向少年的简易编程工具），你可能比较熟悉HTML默认情况下在页面上的布局。</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-11-24/21.png" alt="页面上默认的布局"></p>
<p>基本上，一切都被堆砌在屏幕的顶端。字体比较小，行与行之间完全没有空白。段与段之间有那么一丁点的空白，但并不多。各个段落随着页面伸缩，不管是100像素，还是10000像素。</p>
<p>从美学上讲，这非常的难看。<strong>如果你希望你的UI看起来有设计感，你需要给它增加一些呼吸的空间。</strong></p>
<p>有时候需要的留白很夸张。</p>
<blockquote>
<p>留白、HTML和CSS</p>
<p>如果你，和我一样，曾经使用CSS来实现各种格式，<strong>默认情况下没有留白</strong>，现在是时候从中解脱出来了。试着默认情况下从留白开始思考——一切都以空白开始，直到你拿一个元素来替换它。</p>
<p>很有禅意对吗？我想这是一个人们这么设计的重要原因。</p>
<p><strong>从一个空白页面开始，意味着以一个只有空白的页面开始。</strong>你在一开始就考虑外边距和留白。你画的所有东西都是有意识的在删除空白。</p>
<p><strong>从一堆没样式的HTML开始意味着从内容出发。</strong>事后再考虑空白。必须正确的描述这些。</p>
</blockquote>
<p>以下是<a href="http://www.piotrkwiatkowski.co.uk/" target="_blank" rel="external">Piotr Kwiatkowski</a>的一个音乐播放器的设计图</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-11-24/22.jpeg" alt="音乐播放器"></p>
<p>尤其注意左边的菜单</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-11-24/23.png" alt="左侧的菜单"></p>
<p>在两个菜单项的垂直空白是文字本身的两倍。12px的字体，上下的内边距也是一样。</p>
<p>再看一下列表的标题。在单词“PLAYLISTS”上下有15像素的留白，而且它有下划线。也就是说，在列表与列表之间相距25px。</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-11-24/24.png" alt="导航条上有更多的空白。“Search all music”的文字大小只占导航条高度的20%。图标也差不多大"></p>
<p>不错，大的空白能让凌乱的界面看起来更加诱人和简单——比如下面这个论坛。</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-11-24/25.png" alt="Matt Sisto设计的论坛"></p>
<p>或者维基百科。</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-11-24/26.png" alt="Aurélien Salomon设计的维基百科"></p>
<p>你会发现存在很多争议说，这个重新设计的维基百科省去了使用网页的关键功能。但你必须承认，这是一个不错的学习体验。</p>
<p>增加线条之间的留白</p>
<p>增加元素之间的留白</p>
<p>增加每组元素之间的留白</p>
<p><strong>分析是什么在起作用</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文翻译自Erik D. Kennedy的<a href="https://medium.com/@erikdkennedy/7-rules-for-creating-gorgeous-ui-part-1-559d4e805cda?hn=1">7 Rules for Creating Gorgeous UI (Part 1)</a></p>]]>
    
    </summary>
    
      <category term="设计" scheme="http://lingyu.wang/tags/%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="翻译" scheme="http://lingyu.wang/categories/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Peertc和五子棋]]></title>
    <link href="http://lingyu.wang/2014/11/18/peertc-and-fivechess/"/>
    <id>http://lingyu.wang/2014/11/18/peertc-and-fivechess/</id>
    <published>2014-11-17T16:00:00.000Z</published>
    <updated>2015-05-31T15:00:49.000Z</updated>
    <content type="html"><![CDATA[<p>今天发现博客的分类错乱了。自己写的主题对一篇文章有多个分类的情况处理效果不好，所以就把文章的分类重新弄了一下。然后看了看归档发现这个月还没写过东西，于是乎决定写这么一篇文章介绍一下Peertc，以及使用它实现一个对战的五子棋。下载地址：<a href="https://github.com/LingyuCoder/peertc" target="_blank" rel="external">Peertc</a>、<a href="https://github.com/LingyuCoder/FiveChess" target="_blank" rel="external">五子棋</a></p>
<a id="more"></a>
<h2 id="缘起">缘起</h2><p>之前我曾经写过好几篇关于WebRTC和DataChannel相关的文章。WebRTC是我毕业设计中非常重要的一部分，因此对它做了不少研究。虽然WebRTC的RTC是real-time communication，但它带来的好处并不只局限在即时通信领域。建立点对点通信并在浏览器之间直接传递数据，光这一点就可以提出非常多有趣的设想。有两个应用的点子我一直想做：</p>
<ul>
<li>FC红白机那种双人对战（协作）游戏，配合Canvas和WebGL，这也就是这次五子棋想法的来源。</li>
<li>在线协作编辑：《黑客与画家》中曾经提到过，说在线协作这种工具很有市场。另外除了文档，我们还可以基于Canvas做协作绘图。</li>
</ul>
<p>五子棋就来源一第一个点子。至于第二个，做了一些调研，估计用<a href="https://github.com/Operational-Transformation/ot.js" target="_blank" rel="external">OT.js</a>，只能等有时间的时候去弄了。</p>
<p>FC那么多牛逼的游戏，我却只是做了一个五子棋。原因很简单，Canvas玩的不够熟练也没有素材。五子棋游戏和其他游戏不同的是，它不需要做循环画面刷新，非常适合Canvas上手。</p>
<h2 id="Peertc">Peertc</h2><p><a href="https://github.com/LingyuCoder/peertc" target="_blank" rel="external">Peertc</a>是我在WebRTC DataChannel基础上实现的一个建立点对点通信，发送数据和文件的一个库。由于WebRTC在建立通信信道上还是无法脱离服务器，所以使用Node.js和<a href="https://www.npmjs.org/package/ws" target="_blank" rel="external">ws</a>在后台弄了个WebSocket服务器，同时WebSocket也是很好的退化方案。</p>
<p>至于Peertc具体如何建立点对点连接，我已经在文章<a href="http://lingyu.wang/2014/10/21/datachannel/">使用WebRTC DataChannel在浏览器间传递数据</a>中通过老姚和老刘的故事介绍过了</p>
<p>如果图简单的话，只要知道Peertc就是一个在俩浏览器之间传输数据的库就可以了</p>
<h2 id="五子棋">五子棋</h2><p>我以前没写过五子棋，玩五子棋也玩的比较渣。乘着这个机会，仔细研究了一下五子棋的实现。</p>
<h3 id="实现">实现</h3><p>一个棋盘（多大随意，我玩过15*15的，但是也玩过可以无限扩展的）就是一个二维数组，黑白轮流往棋盘上放棋子，也就是往二维数组里赋值。每次放下棋子，判断一下在当前位置的横线、竖线、两条斜线上是否能成五个相连，也就是判断各个方向是否能成5个数字相同。</p>
<p>状态也只有4个：</p>
<ol>
<li>黑色落子</li>
<li>白色落子</li>
<li>黑色获胜</li>
<li>白色获胜</li>
</ol>
<p>状态转移：</p>
<ul>
<li>初始状态为黑色落子</li>
<li>黑色落子后judge判断是否获胜，若获胜转黑色获胜，否则转白色落子</li>
<li>白色落子后judge判断是否获胜，若获胜转白色获胜，否则转黑色落子</li>
</ul>
<p>所以，五子棋的核心就是一个judge方法来判断是否连成5子，实现很简单</p>
<h3 id="AI">AI</h3><p>为什么要写AI？本来只是想实现双人对战的，那就不要AI了，但是觉着如果只能双人对战未免太过无趣，所以就调研了一下五子棋的AI算法。发现它和计算网页内容的readablity一样，通过计算下在各个位置所获得的分值，得分最高的即是最优解。这里需要注意几个地方：</p>
<ol>
<li>这是一个对战游戏，自己要下子获胜，也要堵别人子防止别人获胜。因此计算权重时两种情况都要考虑</li>
<li>下过五子棋的都知道，如果成了一列（无论方向），两头都没有被堵子肯定要比被堵了一头要强，因此这个是否被堵也要加到考虑当中</li>
<li>连着的越多，越靠近胜利</li>
<li>放在棋盘较为中间的位置比较好（如果棋盘是固定大小的话）</li>
</ol>
<h2 id="双人对战">双人对战</h2><p>既然涉及到双人互动的话，就会涉及到协议了。就算是一个简单的五子棋对战也有协议，这里直接用json好了。由于Peertc帮我们实现了链接和数据传输，A下的子的位置直接传给B就行了。</p>
<p>这里与AI不同的一个地方就是，AI反应快的一笔，不是玩家下子的时候，不做屏蔽也没太大关系。但是玩家需要思考，网络有延迟，所以在上面的黑色落子和白色落子阶段都需要加上对应的屏蔽，保证不会出现该白色落子，黑色依然能下的情况。</p>
<p>那么，需要哪些信令呢？</p>
<h3 id="开一局">开一局</h3><p>开局，这个开局由一方先行发起，发起的一方将自己所持的颜色保存，并将对方应持的颜色和开局指令交给对方，至于颜色怎么来，可以随机或者固定：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">selfColor = <span class="string">'black'</span>;</span><br><span class="line">connector.send(&#123;</span><br><span class="line">    type: <span class="string">'new'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        color: <span class="string">'white'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="落子">落子</h3><p>开局之后，双方都将开始游戏，各自会有自己的游戏数据和状态机。他们的状态应当完全同步。其实可以把对方想象成一个有延迟的AI。落子的关键就在于位置和颜色，位置一般不会有太大问题，而颜色如果错误麻烦就大了<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">connector.send(&#123;</span><br><span class="line">    type: <span class="string">'drop'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        color: fiveChess.state,</span><br><span class="line">        x: x,</span><br><span class="line">        y: y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这里使用的是五子棋内部的状态表明的颜色，而不是使用当前持有的颜色，就是为了防止状态机不同步导致错误。</p>
<h3 id="结束">结束</h3><p>双方在自己或对方落子后可以自行计算是否获胜游戏结束。真正需要传输的游戏结束的信令应当表征有一方认输。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">connector.send(&#123;</span><br><span class="line">    type: <span class="string">'end'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>通过这三个信令，一个对战的五子棋就完成了</p>
<h2 id="结语">结语</h2><p>五子棋属于逻辑比较简单的游戏，因此实现起来很好理解，难度不大。写一个这种基于网络对战游戏，设计好自动机、设计好相互交互的信令是非常重要的。</p>
<p>希望以后Canvas学好了，能够写出像《魂斗罗》，《雪人兄弟》，《拳皇》这样的游戏。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天发现博客的分类错乱了。自己写的主题对一篇文章有多个分类的情况处理效果不好，所以就把文章的分类重新弄了一下。然后看了看归档发现这个月还没写过东西，于是乎决定写这么一篇文章介绍一下Peertc，以及使用它实现一个对战的五子棋。下载地址：<a href="https://github.com/LingyuCoder/peertc">Peertc</a>、<a href="https://github.com/LingyuCoder/FiveChess">五子棋</a></p>]]>
    
    </summary>
    
      <category term="Canvas" scheme="http://lingyu.wang/tags/Canvas/"/>
    
      <category term="JavaScript" scheme="http://lingyu.wang/tags/JavaScript/"/>
    
      <category term="WebIM" scheme="http://lingyu.wang/tags/WebIM/"/>
    
      <category term="WebRTC" scheme="http://lingyu.wang/tags/WebRTC/"/>
    
      <category term="游戏" scheme="http://lingyu.wang/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="算法" scheme="http://lingyu.wang/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="即时通信" scheme="http://lingyu.wang/categories/%E5%8D%B3%E6%97%B6%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用WebRTC DataChannel在浏览器间传递数据]]></title>
    <link href="http://lingyu.wang/2014/10/21/datachannel/"/>
    <id>http://lingyu.wang/2014/10/21/datachannel/</id>
    <published>2014-10-20T16:00:00.000Z</published>
    <updated>2015-05-31T15:00:49.000Z</updated>
    <content type="html"><![CDATA[<p>WebRTC给我们带来了浏览器中的视频、音频聊天体验。但个人认为，它最实用的特性莫过于DataChannel——在浏览器之间建立一个点对点的数据通道。在DataChannel之前，浏览器到浏览器的数据传递通常是这样一个流程：浏览器1发送数据给服务器，服务器处理，服务器再转发给浏览器2。这三个过程都会带来相应的消耗，占用服务器带宽不说，还减缓了消息从发送到接收的时间。其实最理想的方式就是浏览器1直接与浏览2进行通信，服务器不需要参与其中。WebRTC DataChannel就提供了这样一种方式。</p>
<a id="more"></a>
<p>如果对WebRTC和DataChannel不太了解的同学，可以先阅读如下文章：</p>
<ul>
<li><a href="http://lingyu.wang/2014/05/22/webrtc-data-channels/">WebRTC的RTCDataChannel</a></li>
<li><a href="http://lingyu.wang/2014/03/18/webRTC-2/">使用WebRTC搭建前端视频聊天室——信令篇</a></li>
<li><a href="http://lingyu.wang/2014/03/15/webRTC-1/">使用WebRTC搭建前端视频聊天室——入门篇</a></li>
</ul>
<h2 id="老刘和老姚">老刘和老姚</h2><p>当然服务器完全不参与其中，显然是不可能的，用户需要通过服务器上存储的信息，才能确定需要和谁建立连接。这里通过一个故事来讲述建立连接的过程：</p>
<h3 id="不如钓鱼去">不如钓鱼去</h3><p>一些背景：</p>
<ul>
<li>老刘和老姚都住在同一个小区但不同的片区，小区很破旧，没有电话</li>
<li>片区相互隔离且片区门口有个保安，保安只认识自己片区的人，遇到不认识的人就需要查询凭证才能通过，而凭证需要找物业才能确定</li>
<li>门卫老大爷认识小区里的所有人但是不知道都住哪，有什么消息都可以在出入小区的时候代为传达</li>
</ul>
<p>现在，老刘听说老姚钓鱼技术高超，想和老姚讨论钓鱼技巧。只要老刘和老姚相互之间知道对方的门牌号以及凭证，就可以串门了:</p>
<ol>
<li>门卫老大爷认识老刘和老姚</li>
<li>老刘找物业确定了自己片区的出入凭证，将凭证、自己的门牌号以及意图告诉门卫老大爷，让其转交给老姚</li>
<li>老姚买菜归来遇到门卫老大爷，门卫老大爷将老刘的消息传达给老姚。于是老姚知道怎么去老刘家了</li>
<li>老姚很开心，他也找物业获取了自己小区的凭证，并将凭证、自己的门牌号等信息交给门卫老大爷，希望他传达给老刘</li>
<li>老刘吃早餐回来遇到门卫老大爷，老大爷把老姚的小区凭证、门牌号等信息告诉老刘，这样老刘就知道了怎么去老姚家了</li>
</ol>
<p>老刘和老姚相互之间知道了对方的门牌号和小区出入凭证，他们相互之间有什么需要交流的直接串门就行了，消息不再需要门卫老大爷来代为传达了</p>
<h3 id="换个角度">换个角度</h3><p>我们把角色做一个映射：</p>
<ul>
<li>老刘：浏览器1</li>
<li>老姚：浏览器2</li>
<li>片区：不同网段</li>
<li>保安：防火墙</li>
<li>片区凭证：ICE candidate</li>
<li>物业：ICE server</li>
<li>门牌号：session description</li>
<li>门卫老大爷：server</li>
</ul>
<p>于是乎故事就变成了这样：</p>
<ol>
<li>浏览器1和浏览器2在server上注册，并保有连接</li>
<li>浏览器1从ice server获取ice candidate并发送给server，并生成包含session description的offer，发送给server</li>
<li>server发送浏览器1的offer和ice candidate给浏览器2</li>
<li>浏览器2发送包含session description的answer和ice candidate给server</li>
<li>server发送浏览器2的answer和ice candidate给浏览器1</li>
</ol>
<p>这样，就建立了一个点对点的信道，流程如下所示：</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog%2Fimg%2F2014-10-32%2Fdatachannel-task-seq.png" alt="信令交互流程"></p>
<h2 id="礼物">礼物</h2><h3 id="故事">故事</h3><p>老刘和老姚已经可以相互串门了，经过一段时间的交流感情越来越深。老姚的亲友送了20斤葡萄给老姚，老姚决定送10斤给老刘。老姚毕竟年事已高，不可能一次带10斤。于是乎，老姚将葡萄分成了10份，每次去老刘家串门就送一份过去。</p>
<p>这里可以做如下类比：</p>
<ol>
<li>10斤葡萄：一个文件（尽管文件分片没有意义，葡萄分开还可以单独吃，但是实在找不到啥好的比喻了）</li>
<li>分成10份：将文件分片，转成多个chunk</li>
<li>老姚一次只能带一斤：datachannel每次传输的数据量不宜太大（<a href="http://stackoverflow.com/questions/15435121/what-is-the-maximum-size-of-webrtc-data-channel-messages" target="_blank" rel="external">找到最合适的大小</a>）</li>
</ol>
<p>这其实就是通过datachannel传输文件的方式，首先将文件分片，然后逐个发送，最后再统一的进行组合成一个新的文件</p>
<h3 id="分片">分片</h3><p>通过HTML5的File API可以将type为file的input选中的文件读取出来，并转换成data url字符串。这也就为我们提供了很方便的分片方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reader = <span class="keyword">new</span> <span class="built_in">window</span>.FileReader(file);</span><br><span class="line">reader.readAsDataURL(file);</span><br><span class="line">reader.onload = <span class="function"><span class="keyword">function</span>(<span class="params">event, text</span>) </span>&#123;</span><br><span class="line">    chunkify(event.target.result);<span class="comment">//将数据分片</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="组合">组合</h3><p>通过datachannel发送的分片数据，我们需要将其进行组合，由于是data url字符串，在接收到所有包之后进行拼接就可以了。拼接完成后就得到了一个文件完整的data url字符串，那么我们如何将这个字符串转换成文件呢？</p>
<h4 id="方案一：直接跳转下载">方案一：直接跳转下载</h4><p>既然是个dataurl，我们直接将其赋值给<code>window.location.href</code>自然可以下载，但是这样下载是没法设定下载后的文件名的，这想一想都蛋疼</p>
<h4 id="方案二：通过a标签下载">方案二：通过a标签下载</h4><p>这个原理和跳转下载类似，都是使用dataurl本身的特性，通过创建一个a标签，将dataurl字符串赋值给href属性，然后使用download确定下载后的文件名，就可以完成下载了。但是很快又有新问题了，稍微大一点的文件下载的时候页面崩溃了。这是因为dataurl有<a href="http://stackoverflow.com/questions/695151/data-protocol-url-size-limitations" target="_blank" rel="external">大小限制</a></p>
<h4 id="方案三：blob">方案三：blob</h4><p>其实可以通过给a标签创建blob url的方式来进行下载，这个没有大小限制。但是我们手上是dataurl，所以需要先进行转换：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dataURItoBlob</span>(<span class="params">dataURI, dataTYPE</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> binary = atob(dataURI.split(<span class="string">','</span>)[<span class="number">1</span>]),</span><br><span class="line">        array = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; binary.length; i++) array.push(binary.charCodeAt(i));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Blob([<span class="keyword">new</span> <span class="built_in">Uint8Array</span>(array)], &#123;</span><br><span class="line">        type: dataTYPE</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获得blob后，我们就可以通过URL API来下载了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">document</span>.createElement(<span class="string">"a"</span>);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(a);</span><br><span class="line">a.style = <span class="string">"display: none"</span>;</span><br><span class="line"><span class="keyword">var</span> blob = dataURItoBlob(data, <span class="string">'octet/stream'</span>);</span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">window</span>.URL.createObjectURL(blob);</span><br><span class="line">a.href = url;</span><br><span class="line">a.download = filename;</span><br><span class="line">a.click();</span><br><span class="line">!moz &amp;&amp; <span class="built_in">window</span>.URL.revokeObjectURL(url);</span><br><span class="line">a.parentNode.removeChild(a);</span><br></pre></td></tr></table></figure>
<p>这里有几个点：</p>
<ol>
<li>datachannel其实是可以直接传送blob的，但是只有ff支持，所以传data url</li>
<li>chrome下载是直接触发的，不会进行询问，firefox会先询问后下载，在询问过程中如果执行了<code>revokeObjectURL</code>，下载就会取消，囧</li>
</ol>
<h2 id="升级">升级</h2><p>如我们所知，WebRTC最有特点的地方其实是可以传输getUserMedia获得的视频、音频流，来实现视频聊天。但事实上我们的使用习惯来看，一般人不会一开始就打开视频聊天，而且视频聊天时很消耗内存的（32位机上一个连接至少20M左右好像，也有可能有出入）。所以常见的需求是，先建立一个包含datachannel的连接用于传输数据，然后在需要时升级成可以传输视频、音频。</p>
<p>看看我们之前传输的session description，它其实来自<a href="http://datatracker.ietf.org/doc/draft-nandakumar-rtcweb-sdp/?include_text=1" target="_blank" rel="external">Session Description Protocol</a>。可以看到wiki上的介绍：</p>
<blockquote>
<p>The Session Description Protocol (SDP) is a format for describing streaming media initialization parameters.</p>
</blockquote>
<p>这意味着什么呢？我们之前建立datachannel是没有加视频、音频流的，而这个流的描述是写在SDP里面的。现在我们需要传输视频、音频，就需要添加这些描述。所以就得重新获得SDP，然后构建offer和answer再传输一次。传输的流程和之前一样，没什么区别。但这一次，我们不需要传输任何的ice candidate，这里我曾经<a href="http://stackoverflow.com/questions/26469794/webrtc-add-ice-candidate-error-on-established-peerconnection" target="_blank" rel="external">遇到了坑</a>，经过国外大大的点拨才明白过来。</p>
<blockquote>
<p>from mattm: You do not need to send ICE candidates on an already established peer connection. The ICE candidates are to make sure the two peers can establish a connection through their potential NAT and firewalls. If you can already send data on the peer connection, ICE candidates will not do anything.</p>
</blockquote>
<h2 id="Peertc">Peertc</h2><p>我将datachannel和websocket组合，实现了一个构建点对点连接的库Peertc，它提供非常简洁的方式来建立连接和发送数据、文件和视频/音频流，详情见<a href="https://github.com/LingyuCoder/peertc" target="_blank" rel="external">github</a>。走过路过的记得star一下哦，有什么bug也非常希望能够提出来。</p>
<h2 id="最后">最后</h2><p>WebRTC的点对点方式能够运用在很多场景：</p>
<ul>
<li>如web qq这种Web IM工具，这就不说了</li>
<li>如象棋这种双人对战游戏，每一步的数据服务器时不关心的，所以完全可以点对点发送</li>
<li>一对一在线面试、在线教育，这其实是即时通信的一个业务方向</li>
<li>视频裸（），当我没说</li>
</ul>
<p>就酱，另外打个广告及拉点搜索引擎权重：<a href="http://lingyu.wang">我的博客</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>WebRTC给我们带来了浏览器中的视频、音频聊天体验。但个人认为，它最实用的特性莫过于DataChannel——在浏览器之间建立一个点对点的数据通道。在DataChannel之前，浏览器到浏览器的数据传递通常是这样一个流程：浏览器1发送数据给服务器，服务器处理，服务器再转发给浏览器2。这三个过程都会带来相应的消耗，占用服务器带宽不说，还减缓了消息从发送到接收的时间。其实最理想的方式就是浏览器1直接与浏览2进行通信，服务器不需要参与其中。WebRTC DataChannel就提供了这样一种方式。</p>]]>
    
    </summary>
    
      <category term="DataChannel" scheme="http://lingyu.wang/tags/DataChannel/"/>
    
      <category term="JavaScript" scheme="http://lingyu.wang/tags/JavaScript/"/>
    
      <category term="NodeJs" scheme="http://lingyu.wang/tags/NodeJs/"/>
    
      <category term="WebIM" scheme="http://lingyu.wang/tags/WebIM/"/>
    
      <category term="WebRTC" scheme="http://lingyu.wang/tags/WebRTC/"/>
    
      <category term="WebSocket" scheme="http://lingyu.wang/tags/WebSocket/"/>
    
      <category term="即时通信" scheme="http://lingyu.wang/categories/%E5%8D%B3%E6%97%B6%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Gulp思维 —— Gulp高级技巧]]></title>
    <link href="http://lingyu.wang/2014/10/07/getting-gulpy/"/>
    <id>http://lingyu.wang/2014/10/07/getting-gulpy/</id>
    <published>2014-10-06T16:00:00.000Z</published>
    <updated>2015-05-31T15:00:49.000Z</updated>
    <content type="html"><![CDATA[<p><strong>本文翻译自<a href="https://medium.com/@webprolific/getting-gulpy-a2010c13d3d5" target="_blank" rel="external">Getting gulpy — Advanced tips for using gulp.js</a></strong></p>
<p>感受过<a href="http://gulpjs.com/" target="_blank" rel="external">gulp.js</a>带来的兴奋过后，你需要的不仅仅是它的光鲜，而是切切实实的实例。这篇文章讨论了一些使用gulp.js时常踩的坑，以及一些更加高级和定制化的插件和流的使用技巧。</p>
<a id="more"></a>
<h2 id="基本任务">基本任务</h2><p>gulp的基本设置拥有非常友好的语法，让你能够非常方便的对文件进行转换：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(<span class="string">'scripts'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'./src/**/*.js'</span>)</span><br><span class="line">        .pipe(uglify())</span><br><span class="line">        .pipe(concat(<span class="string">'all.min.js'</span>))</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'build/'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这种方式能够应付绝大多数情况，但如果你需要更多的定制，很快就会遇到麻烦了。这篇将介绍这其中的一些情况并提供解决方案。</p>
<h2 id="流不兼容？">流不兼容？</h2><p>使用gulp时，你可能会陷入“流不兼容”的问题。这主要是因为常规流和Vinyl文件对象有差异，或是使用了仅支持buffer（不支持流）库的gulp插件与常规流不兼容。</p>
<p>比如说，你不能直接将常规流与gulp和（或）gulp插件相连。我们创建一个可读流，并尝试使用<a href="https://www.npmjs.org/package/gulp-uglify" target="_blank" rel="external">gulp-uglify</a>和<a href="https://www.npmjs.org/package/gulp-rename" target="_blank" rel="external">gulp-rename</a>来进行转换，将最后得到的内容交给<code>gulp.dest()</code>。下面就是个错误的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>),</span><br><span class="line">    rename = <span class="built_in">require</span>(<span class="string">'gulp-rename'</span>);</span><br><span class="line">gulp.task(<span class="string">'bundle'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fs.createReadStream(<span class="string">'app.js'</span>)</span><br><span class="line">        .pipe(uglify())</span><br><span class="line">        .pipe(rename(<span class="string">'bundle.min.js'</span>))</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'dist/'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>为什么我们不能将可读流和一个gulp插件直接相连？gulp难道不就是一个基于流的构建系统吗？是的，但上面的例子忽视了一个事实，gulp插件期望的输入是Vinyl文件对象。你不能直接将一个可读流与一个以Vinyl文件对象作为输入的函数（插件）相连</p>
<h2 id="Vinyl文件对象">Vinyl文件对象</h2><p>gulp使用了<a href="https://github.com/wearefractal/vinyl-fs" target="_blank" rel="external">vinyl-fs</a>，它实现了<code>gulp.src()</code>和<code>gulp.dest()</code>方法。vinyl-fs使用<a href="https://github.com/wearefractal/vinyl" target="_blank" rel="external">vinyl</a>文件对象——一种“虚拟文件格式”。如果我们需要将gulp和（或）gulp插件与常规的可读流一起使用，我们就需要先把可读流转换为vinyl。</p>
<p>使用<a href="https://www.npmjs.org/package/vinyl-source-stream" target="_blank" rel="external">vinyl-source-stream</a>是个不错的选择，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = <span class="built_in">require</span>(<span class="string">'vinyl-source-stream'</span>),</span><br><span class="line">    marked = <span class="built_in">require</span>(<span class="string">'gulp-marked'</span>);</span><br><span class="line">fs.createReadStream(<span class="string">'*.md'</span>)</span><br><span class="line">    .pipe(source())</span><br><span class="line">    .pipe(marked())</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'dist/'</span>));</span><br></pre></td></tr></table></figure>
<p>另外一个例子首先通过<a href="http://browserify.org/" target="_blank" rel="external">browserify</a>封装并最终将其转换为一个vinyl流：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> browserify = <span class="built_in">require</span>(<span class="string">'browserify'</span>),</span><br><span class="line">    uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>),</span><br><span class="line">    source = <span class="built_in">require</span>(<span class="string">'vinyl-source-stream'</span>);</span><br><span class="line">gulp.task(<span class="string">'bundle'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> browserify(<span class="string">'./src/app.js'</span>)</span><br><span class="line">        .bundle()</span><br><span class="line">        .pipe(source(‘bundle.min.js))</span><br><span class="line">        .pipe(uglify())</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'dist/'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>哎呦不错哦。注意我们不再需要使用gulp-rename了，因为vinyl-source-stream创建了一个拥有指定文件名的vinyl文件实例（这样gulp.dest方法将使用这个文件名）</p>
<h3 id="gulp-dest">gulp.dest</h3><p>这个gulp方法创建了一个可写流，它真的很方便。它重新使用可读流中的文件名，然后在必要时创建文件夹（使用<a href="https://www.npmjs.org/package/mkdirp" target="_blank" rel="external">mkdirp</a>）。在写入操作完成后，你能够继续使用这个流（比如：你需要使用gzip压缩数据并写入到其他文件）</p>
<h2 id="流和buffer">流和buffer</h2><p>既然你有兴趣使用gulp，这篇文章假设你已经了解了流的基础知识。无论是buffer还是流，vinyl的虚拟文件都能包含在内。使用常规可读流时，你可以监听data事件来检测数据碎片的到来：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fs.createReadStream(<span class="string">'/usr/share/dict/words'</span>).on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Read %d bytes of data'</span>, chunk.length);</span><br><span class="line">&#125;);</span><br><span class="line">&gt; Read <span class="number">65536</span> bytes <span class="keyword">of</span> data</span><br><span class="line">&gt; Read <span class="number">65536</span> bytes <span class="keyword">of</span> data</span><br><span class="line">&gt; Read <span class="number">65536</span> bytes <span class="keyword">of</span> data</span><br><span class="line">&gt; Read <span class="number">65536</span> bytes <span class="keyword">of</span> data</span><br><span class="line">&gt; ...</span><br></pre></td></tr></table></figure>
<p>不同的是，使用<code>gulp.src()</code>会将转换成buffer的vinyl文件对象重新写入到流中。也就是说，你获得的不再是数据碎片，而是将内容转换成buffer后的（虚拟）文件。vinyl文件格式拥有一个属性来表示里面是buffer还是流，gulp默认使用buffer：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gulp.src(<span class="string">'/usr/share/dict/words'</span>).on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Read %d bytes of data'</span>, file.contents.length);</span><br><span class="line">&#125;);</span><br><span class="line">&gt; Read <span class="number">2493109</span> bytes <span class="keyword">of</span> data</span><br></pre></td></tr></table></figure>
<p>这个例子说明了在文件被完整加入到流之前数据会被转换成buffer。</p>
<h2 id="Gulp默认使用buffer">Gulp默认使用buffer</h2><p>尽管更加推荐使用流中的数据，但很多插件的底层库使用的是buffer。有时候必须使用buffer，因为转换需要完整的文件内容。比如文本替换和正则表达式的情形。如果使用数据碎片，将会面临匹配失败的风险。同样，像<a href="http://lisperator.net/uglifyjs/" target="_blank" rel="external">UglifyJS</a>和<a href="https://github.com/google/traceur-compiler" target="_blank" rel="external">Traceur Compiler</a>需要输入完整的文件内容（至少需要语法完整的JavaScript字符串）</p>
<p>这就是为什么gulp默认使用转换成buffer的流，因为这更好处理。</p>
<p>使用转换成buffer的流也有缺点，处理大文件时将非常低效。文件必须完全读取，然后才能被加入到流中。那么问题来了，文件的尺寸多大才会降低性能？对于普通的文本文件，比如JavaScript、CSS、模板等等，这些使用buffer开销非常小。</p>
<p>在任何情况下，如果将buffer选项设为false，你可以告诉gulp流中传递的内容究竟是什么。如下所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gulp.src(<span class="string">'/usr/share/dict/words'</span>, &#123;buffer: <span class="literal">false</span>&#125;).on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> stream = file.contents;</span><br><span class="line">    stream.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Read %d bytes of data'</span>, chunk.length);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&gt; Read <span class="number">65536</span> bytes <span class="keyword">of</span> data</span><br><span class="line">&gt; Read <span class="number">65536</span> bytes <span class="keyword">of</span> data</span><br><span class="line">&gt; Read <span class="number">65536</span> bytes <span class="keyword">of</span> data</span><br><span class="line">&gt; Read <span class="number">65536</span> bytes <span class="keyword">of</span> data</span><br><span class="line">&gt; ...</span><br></pre></td></tr></table></figure></p>
<h2 id="从流到buffer">从流到buffer</h2><p>由于所需的输入（输出）流和gulp插件不尽相同，你可能需要将流转换成buffer（反之亦然）。之前已经有过介绍，大多数插件使用buffer（尽管他们的一部分也支持流）。比如<a href="https://www.npmjs.org/package/gulp-uglify" target="_blank" rel="external">gulp-uglify</a>和<a href="https://www.npmjs.org/package/gulp-traceur" target="_blank" rel="external">gulp-traceur</a>。你可以通过<a href="https://www.npmjs.org/package/gulp-buffer" target="_blank" rel="external">gulp-buffer</a>来转换成buffer：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = <span class="built_in">require</span>(<span class="string">'vinyl-source-stream'</span>),</span><br><span class="line">    buffer = <span class="built_in">require</span>(<span class="string">'gulp-buffer'</span>),</span><br><span class="line">    uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>);</span><br><span class="line">fs.createReadStream(<span class="string">'./src/app.js'</span>)</span><br><span class="line">    .pipe(source(<span class="string">'app.min.js'</span>))</span><br><span class="line">    .pipe(buffer())</span><br><span class="line">    .pipe(uglify())</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'dist/'</span>));</span><br></pre></td></tr></table></figure>
<p>或者另一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buffer = <span class="built_in">require</span>(<span class="string">'gulp-buffer'</span>),</span><br><span class="line">    traceur = <span class="built_in">require</span>(<span class="string">'gulp-traceur'</span>);</span><br><span class="line">gulp.src(<span class="string">'app.js'</span>, &#123;buffer: <span class="literal">false</span>&#125;)</span><br><span class="line">    .pipe(buffer())</span><br><span class="line">    .pipe(traceur())</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'dist/'</span>));</span><br></pre></td></tr></table></figure>
<h2 id="将buffer转换为流">将buffer转换为流</h2><p>你也可以使用<a href="https://www.npmjs.org/package/gulp-streamify" target="_blank" rel="external">gulp-streamify</a>或<a href="https://www.npmjs.org/package/gulp-stream" target="_blank" rel="external">gulp-stream</a>将一个使用buffer的插件的输出转化为一个可读流。这样处理之后，跟在使用buffer的插件后面的（只能）使用流的插件也能正常工作了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wrap = <span class="built_in">require</span>(<span class="string">'gulp-wrap'</span>),</span><br><span class="line">    streamify = <span class="built_in">require</span>(<span class="string">'gulp-streamify'</span>),</span><br><span class="line">    uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>),</span><br><span class="line">    gzip = <span class="built_in">require</span>(<span class="string">'gulp-gzip'</span>);</span><br><span class="line">gulp.src(<span class="string">'app.js'</span>, &#123;buffer: <span class="literal">false</span>&#125;)</span><br><span class="line">    .pipe(wrap(<span class="string">'(function()&#123;&lt;%= contents %&gt;&#125;());'</span>))</span><br><span class="line">    .pipe(streamify(uglify()))</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'build'</span>))</span><br><span class="line">    .pipe(gzip())</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'build'</span>));</span><br></pre></td></tr></table></figure>
<h2 id="不是所有事都需要插件">不是所有事都需要插件</h2><p>虽然已经有很多使用且方便的插件，很多任务以及转换可以不使用插件而轻易完成。插件会带来一些问题，你需要依赖一个额外的npm模块，一个插件接口和（反应迟钝？）的维护者，等等。如果一个任务可以不使用插件而使用原生模块就能轻易完成，绝大多数情况下，都建议不要使用插件。能够理解上面所说的概念，并能够在所处的情况下做出正确的决定，这点非常重要。下面来看一些例子：</p>
<h3 id="vinyl-source-stream">vinyl-source-stream</h3><p>之前的例子中，我们已经直接使用了browserify，而不是使用（现已加入黑名单）<a href="https://www.npmjs.org/package/gulp-browserify" target="_blank" rel="external">gulp-browserify</a>插件。这里的关键是使用vinyl-source-stream（或类似的库）进行加工，来将常规的可读流输入使用vinyl的插件。</p>
<h3 id="文本转换">文本转换</h3><p>另一个例子就是基于字符串的变换。这里有一个非常基础的插件，直接使用了vinyl的buffer：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">modify</span>(<span class="params">modifier</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> through2.obj(<span class="function"><span class="keyword">function</span>(<span class="params">file, encoding, done</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> content = modifier(<span class="built_in">String</span>(file.contents));</span><br><span class="line">        file.contents = <span class="keyword">new</span> Buffer(content);</span><br><span class="line">        <span class="keyword">this</span>.push(file);</span><br><span class="line">        done();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你可以像这样使用这个插件：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(<span class="string">'modify'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'app.js'</span>)</span><br><span class="line">        .pipe(modify(version))</span><br><span class="line">        .pipe(modify(swapStuff))</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'build'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">version</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data.replace(<span class="regexp">/__VERSION__/</span>, pkg.version);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swapStuff</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data.replace(<span class="regexp">/(\w+)\s(\w+)/</span>, <span class="string">'$2, $1'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个插件并没有完成，而且也不能处理流（<a href="https://gist.github.com/webpro/a9a9e14d291c021894b3" target="_blank" rel="external">完整版本</a>）。然而，这个例子说明，可以很轻易地通过一些基本函数来创建新的变换。<a href="https://www.npmjs.org/package/through2" target="_blank" rel="external">through2</a>库提供了非常优秀的Node流封装，并且允许像上面那样使用转换函数。</p>
<h2 id="任务流程">任务流程</h2><p>如果你需要去运行一些定制化或动态的任务，了解gulp所使用的<a href="https://www.npmjs.org/package/orchestrator" target="_blank" rel="external">Orchestrator</a>模块会很有帮助。<code>gulp.add</code>方法其实就是<code>Orchestrator.add</code>方法（事实上所有的方法都是从Orchestrator继承而来的）。但为什么你需要这个？</p>
<ul>
<li>你不想“私有任务”（比如：不暴露给命令行工具）弄乱gulp任务列表。</li>
<li>你需要更多的动态的和（或）可重用的子任务。</li>
</ul>
<h2 id="最后的思考">最后的思考</h2><p>请注意，gulp（或grunt）并不总是当前情境下的最佳工具。比如说，如果你需要拼接并使用uglify压缩一系列的JavaScript文件，又或者你需要编译一些SASS文件，你可能需要考虑使用makefile或npm run，通过命令行来实现。减少依赖，减少配置，才是正解。</p>
<p>阅读<a href="http://substack.net/task_automation_with_npm_run" target="_blank" rel="external">通过npm run来实现任务自动化</a>来了解更多信息。你需要明确通过一系列的“自定义构建”后需要得到什么，而哪个工具最合适。</p>
<p>不过，我觉得gulp是一个伟大的构建系统，我很喜欢使用它，它展现了Node.js中流的强大。</p>
<p>希望这些能够帮到你！如果你有任何反馈或其他提议，请在评论中告诉我，或者加我的twitter：<a href="https://twitter.com/webprolific" target="_blank" rel="external">@webprolific</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>本文翻译自<a href="https://medium.com/@webprolific/getting-gulpy-a2010c13d3d5">Getting gulpy — Advanced tips for using gulp.js</a></strong></p>
<p>感受过<a href="http://gulpjs.com/">gulp.js</a>带来的兴奋过后，你需要的不仅仅是它的光鲜，而是切切实实的实例。这篇文章讨论了一些使用gulp.js时常踩的坑，以及一些更加高级和定制化的插件和流的使用技巧。</p>]]>
    
    </summary>
    
      <category term="Gulp" scheme="http://lingyu.wang/tags/Gulp/"/>
    
      <category term="JavaScript" scheme="http://lingyu.wang/tags/JavaScript/"/>
    
      <category term="NodeJs" scheme="http://lingyu.wang/tags/NodeJs/"/>
    
      <category term="翻译" scheme="http://lingyu.wang/categories/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Gulp -- 项目的愿景、过去和将来]]></title>
    <link href="http://lingyu.wang/2014/10/06/gulp-vision-history-future/"/>
    <id>http://lingyu.wang/2014/10/06/gulp-vision-history-future/</id>
    <published>2014-10-05T16:00:00.000Z</published>
    <updated>2015-05-31T15:00:49.000Z</updated>
    <content type="html"><![CDATA[<p><strong>本文翻译自<a href="https://medium.com/@contrahacks/gulp-3828e8126466" target="_blank" rel="external">gulp — The vision, history, and future of the project</a></strong></p>
<p>gulp是一个将vinyl、vinyl-fs、orchestrator、命令行工具以及一系列用于帮助开发者构建优秀插件的指导方针等集于一身的小巧构建工具。尽管它功能很少，但它却完全打破了构建工具生态体系，并通过许多优秀的项目掀起了一股改革你的工作流程的浪潮。</p>
<a id="more"></a>
<p>下面我们就来介绍gulp背后的各个部分以及它们所起到的作用。</p>
<h2 id="流">流</h2><p>流是一种将多个小的变换操作进行组合，连接成管道的一种方式。你将数据丢入管道顶部，它将下落并穿过所有的变换，最后在底部得到你想要的内容。流系统的灵活性能够很好地解决文件变换需求。</p>
<p>想获得更多关于流的信息，请查阅substack的<a href="https://github.com/substack/stream-handbook" target="_blank" rel="external">流操作手册</a></p>
<h2 id="Vinyl">Vinyl</h2><p><a href="https://github.com/wearefractal/vinyl" target="_blank" rel="external">Vinyl</a>是一个用来描述文件的简单元数据对象。当你想要使用一个文件时，首先映入脑海的是文件的两个属性：<a href="https://github.com/wearefractal/vinyl/blob/master/index.js#L18-L25" target="_blank" rel="external">路径和内容</a>。这两个属性就是一个Vinyl对象的主要属性。这里的文件并不一定是指你的文件系统里的文件。你在S3、FTP、Dropbox、Box、CloudThingly.io或者其他服务上的文件，一样可以使用Vinyl来描述。</p>
<h2 id="Vinyl_Adapters（Vinyl适配器）">Vinyl Adapters（Vinyl适配器）</h2><p>既然Vinyl提供了一个清晰的方法用来描述文件，我们现在还需要找到访问这些文件的方式。每一种文件源我们都需要一个“Vinyl适配器”。一个Vinyl适配器只需要暴露三个方法：<code>.src(globs)</code>、<code>.dest(folder)</code>、和一个<code>.watch(globs, fn)</code>。src流负责产生文件对象，而dest流负责消费这些文件对象。</p>
<p>表面上看人们已经理解了“gulp插件”(一个transform形式的流)的概念，但Vinyl适配器的理念却没有被广泛传播。除非自己开发一些适配器，否则无法得知适配器是如何引用文件源中的内容。。通过Vinyl适配器来实现gulp，并将其作为一个开发工具的想法非常奇妙。</p>
<h3 id="vinyl-fs">vinyl-fs</h3><p>如果你使用gulp，你已经使用了<a href="https://github.com/wearefractal/vinyl-fs" target="_blank" rel="external">vinyl-fs</a>模块。它是用来适配本地文件系统的适配器。</p>
<h3 id="vinyl-s3">vinyl-s3</h3><p>vinyl-s3尚不存在，但<a href="https://github.com/nkostelnik/gulp-s3" target="_blank" rel="external">gulp-s3</a>已经实现了。它无法提供所有的功能，但它是了一个不错的权宜方案。</p>
<h2 id="Orchestrator">Orchestrator</h2><p>在写这篇文章时，目前的任务系统是<a href="https://github.com/orchestrator/orchestrator" target="_blank" rel="external">Orchestrator</a> 0.3。Orchestrator提供了简单的方式去定义任务和依赖，并能够在依赖树为基础的前提下以最大并发数去与并发执行这些任务。Orchestrator虽然工作良好，但它复杂的依赖管理给用户带来不小的麻烦。Orchestrator为了配合gulp的理念而做了巨大的调整：更加轻量、低复杂度，以及可组合的功能性API。</p>
<p>这里简要介绍一下gulp 4带来的变化：</p>
<ol>
<li>你可以任意指定任务顺序，并行/串行的任意组合都随心所欲。只有想不到，没有做不到</li>
<li>API将非常流畅和友好</li>
<li>代码更加简洁</li>
</ol>
<p>非常感谢Blaine Bublitz在这方面积极的努力。</p>
<h2 id="错误处理">错误处理</h2><p>实话告诉你：gulp现在的错误处理很烂。我从不期望能从报错信息中获得一点有用的信息。使用gulp的过程中，你可能会遭遇两种错误：</p>
<h3 id="任务失败">任务失败</h3><p>watch时出现任务失败，内部将会一团糟，然后线程会退出，具体的退出方式要取决你如何启动这个任务。这种情况非常糟糕，完全不应该发生，在新的任务系统中将对这些进行修复。</p>
<h3 id="管道失败">管道失败</h3><p>标准的流在遭遇错误时仅仅会停止工作。而像linter（代码风格检测）这样的任务，问题就来了。我想看到所有的代码风格提示，而不只是第一个文件里的那些。技术上其实是因为unpipe事件。本质上看，当一个流遇到错误，它将会触发<strong>unpipe</strong>事件，这个事件将告诉其他流不再向它写入数据。目前有一些hack的解决方法如gulp-plumber，可以作为权宜之计，但我很高兴的说，我将会把这些集成到gulp核心之中去。</p>
<p>这些问题我会在下个release版本最优先解决。</p>
<h2 id="社区">社区</h2><p>从一个局外人的角度来看，人们都能参与到这场文件转换工具的战斗之中，实在有些疯狂。虽然外人看来可能有些无趣，但成为这个激情小组的一部分绝对令人振奋。我很自豪社区能够接纳这个工具并对人们的日常生活带来帮助。</p>
<h2 id="进展">进展</h2><p>想要跟踪gulp 4的进展，你可以在github上查看<a href="https://github.com/gulpjs/gulp/issues?milestone=1&amp;state=open" target="_blank" rel="external">里程碑</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>本文翻译自<a href="https://medium.com/@contrahacks/gulp-3828e8126466">gulp — The vision, history, and future of the project</a></strong></p>
<p>gulp是一个将vinyl、vinyl-fs、orchestrator、命令行工具以及一系列用于帮助开发者构建优秀插件的指导方针等集于一身的小巧构建工具。尽管它功能很少，但它却完全打破了构建工具生态体系，并通过许多优秀的项目掀起了一股改革你的工作流程的浪潮。</p>]]>
    
    </summary>
    
      <category term="Gulp" scheme="http://lingyu.wang/tags/Gulp/"/>
    
      <category term="JavaScript" scheme="http://lingyu.wang/tags/JavaScript/"/>
    
      <category term="NodeJs" scheme="http://lingyu.wang/tags/NodeJs/"/>
    
      <category term="翻译" scheme="http://lingyu.wang/categories/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[koa-anywhere]]></title>
    <link href="http://lingyu.wang/2014/09/24/koa-anywhere/"/>
    <id>http://lingyu.wang/2014/09/24/koa-anywhere/</id>
    <published>2014-09-23T16:00:00.000Z</published>
    <updated>2015-05-31T15:00:49.000Z</updated>
    <content type="html"><![CDATA[<p>最近写了一个快速启动静态文件服务器的NodeJs包<a href="https://github.com/LingyuCoder/koa-anywhere" target="_blank" rel="external">koa-anywhere</a>，可以通过一条命令快速的启动静态文件服务器，而且支持多级目录。目前已经发到了NPM上了</p>
<a id="more"></a>
<h1 id="koa-anywhere">koa-anywhere</h1><p>通过一条命令，将当前目录变成一个静态文件服务器</p>
<p>需要Node版本：&gt;= 0.11.13</p>
<h1 id="Install">Install</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g koa-anywhere</span><br></pre></td></tr></table></figure>
<h1 id="Usage">Usage</h1><p>只需一条简单的命令<code>ka</code>就可以启动一个静态文件服务器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd &#60;&#24819;&#35201;&#20849;&#20139;&#30340;&#30446;&#24405;&#62;&#10;$ ka</span><br></pre></td></tr></table></figure></p>
<h2 id="Option">Option</h2><h3 id="port">port</h3><p>通过<code>-p &lt;端口号&gt;</code>或者<code>--port &lt;端口号&gt;</code>来指定静态文件服务器的端口</p>
<p>默认端口为<code>3000</code></p>
<h3 id="deep">deep</h3><p>通过<code>-d &lt;层级数&gt;</code>或者<code>--deep &lt;层级数&gt;</code>来确定静态文件需要显示的文件层级，超过层级的文件不显示</p>
<p>默认层级数为<code>3</code></p>
<h3 id="silent">silent</h3><p>通过<code>-s</code>或者<code>--silent</code>来决定是否显示日志</p>
<p>默认为<code>false</code>，也就是显示日志</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近写了一个快速启动静态文件服务器的NodeJs包<a href="https://github.com/LingyuCoder/koa-anywhere">koa-anywhere</a>，可以通过一条命令快速的启动静态文件服务器，而且支持多级目录。目前已经发到了NPM上了</p>]]>
    
    </summary>
    
      <category term="ES6" scheme="http://lingyu.wang/tags/ES6/"/>
    
      <category term="NodeJs" scheme="http://lingyu.wang/tags/NodeJs/"/>
    
      <category term="koa" scheme="http://lingyu.wang/tags/koa/"/>
    
      <category term="NodeJs" scheme="http://lingyu.wang/categories/NodeJs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[学前端的一点总结]]></title>
    <link href="http://lingyu.wang/2014/09/22/learn-fe/"/>
    <id>http://lingyu.wang/2014/09/22/learn-fe/</id>
    <published>2014-09-21T16:00:00.000Z</published>
    <updated>2015-05-31T15:00:49.000Z</updated>
    <content type="html"><![CDATA[<p>最近<a href="https://github.com/qiu-deqing" target="_blank" rel="external">Qiu</a>开了一个<a href="https://github.com/qiu-deqing/FE-learning/blob/master/README.md" target="_blank" rel="external">FE学习经验介绍</a>，并邀请我去写一点东西。感觉这种方式很有意思，趁着闲下来了，就随便扯了一些，希望能帮到想学前端的同学。我自己只是个前端初学者，希望能有更多的前端爱好者一同学习探讨~~</p>
<a id="more"></a>
<h4 id="工具">工具</h4><ul>
<li>chrome dev tools：前端开发调试利器，着重注意几个功能：<ul>
<li>console（废话）</li>
<li>elements:元素样式调整，很常用</li>
<li>sources：代码中添加断点，单步调试，以及单步调试过程中查看内存中的对象<ul>
<li>watch expression：通过表达式查看当前内存中的值</li>
<li>call stack：查看调用栈，开启async，可以看异步调用栈（这个非常有用，尤其是ajax调试的时候）</li>
<li>scope variables：作用域链上的变量，非常有用</li>
</ul>
</li>
<li>network：抓包查看每个请求，非常重要，前后端联调必备</li>
<li>timeline：分析渲染、js执行等等各个阶段，性能优化利器</li>
<li>emulation：模拟移动端环境，mobile页面开发必备</li>
<li>一些插件:<ul>
<li>liveload: 修改页面后自动刷新，不用按F5</li>
<li>dimensions：直接在页面上测量的利器</li>
<li>livestyle：css样式修改后自动起效果，不需要刷新，elements修改后也能同步到代码中</li>
<li>image tool：测量，取色</li>
<li>UC二维码：移动端调试扫码必备</li>
<li>pagespeed，YSlow：页面性能分析和优化插件</li>
<li>马克飞象：优秀的在线markdown编辑器，快速写周报，做记录</li>
</ul>
</li>
</ul>
</li>
<li>sublime text2：编码方便，插件多，速度快，性能好<ul>
<li>emmet：提升html编码速度必备</li>
<li>sublimelinter + 各种语言的lint和hint：代码纠错</li>
<li>一些snippets：自动补全，提升开发效率</li>
</ul>
</li>
<li>Intellij IDEA和WebStorm：集成开发环境，集成了各种功能，开发比sublime要方便，但会比较吃性能</li>
<li>Mark Men：测量、取色、标注利器，拿到视觉稿之后第一个打开的软件</li>
<li>GFW Fucker：我用红杏，可以的话买个虚拟服务器当梯子</li>
<li>iHosts：非常优秀的hosts管理软件，轻松修改hosts，开发调试必备</li>
<li>Rythem：AlloyTeam出品的代理抓包软件，非常轻量，安装简单，移动端（真机）开发调试很好用</li>
<li>Wunderlist：一个非常不错的Todo List，任务、需求多的时候管理起来很方便</li>
</ul>
<h4 id="技能">技能</h4><p>前端的技能其实除了JavaScript（包括NodeJS）、HTML、CSS以外，还有很多。其实前端的技能树很大，这里只能列一些我开发中见到的说一说</p>
<h5 id="语言基础">语言基础</h5><p>JavaScript：</p>
<ul>
<li>作用域链、闭包、运行时上下文、this</li>
<li>原型链、继承</li>
<li>NodeJS基础和常用API</li>
</ul>
<p>CSS：</p>
<ul>
<li>选择器</li>
<li>浏览器兼容性及常见的hack处理</li>
<li>CSS布局的方式和原理（盒子模型、BFC、IFC等等）</li>
<li>CSS 3，如animation、gradient、等等</li>
</ul>
<p>HTML：</p>
<ul>
<li>语义化标签</li>
</ul>
<h5 id="进阶">进阶</h5><p>JavaScript:</p>
<ul>
<li>异步控制（Promise、ES6 generator、Async）</li>
<li>模块化的开发方式（AMD、CMD、KMD等等）</li>
<li>JavaScript解释器的一些相关知识<ul>
<li>异步IO实现</li>
<li>垃圾回收</li>
<li>事件队列</li>
</ul>
</li>
<li>常用框架使用及其原理<ul>
<li>jQuery：基于选择器的框架，但个人认为不能叫框架，应该算工具库，因为不具备模块加载机制，其中源码很适合阅读钻研</li>
<li>AngularJS/Avalon等MVVM框架：着重理解MVVM模式本身的理念和双向绑定的实现，如何解耦</li>
<li>underscore：优秀的工具库，方便的理解常用工具代码片段的实现</li>
<li>polymer/React: 组件化开发，面向未来，理解组件化开发的原理</li>
</ul>
</li>
</ul>
<p>CSS和HTML：主要是CSS3的特性和HTML5的特性，以及浏览器处理的流程和绘制原理</p>
<ul>
<li>DOM树、CSSOM树、渲染树的构建流程及页面渲染的过程</li>
<li>解析HTML、CSS、JavaScript时造成的阻塞</li>
<li>HTML5相关<ul>
<li>SVG及矢量图原理</li>
<li>Canvas开发及动画原理（帧动画）</li>
<li>Video和Audio</li>
</ul>
</li>
<li>flex box布局方式</li>
<li>icon fonts的使用</li>
</ul>
<p>常用NodeJs的package：</p>
<ul>
<li>koa</li>
<li>express</li>
<li>underscore</li>
<li>async</li>
<li>gulp</li>
<li>grunt</li>
<li>connect</li>
<li>request</li>
</ul>
<p>一些理念：</p>
<ul>
<li>响应式Web</li>
<li>优雅降级、渐进增强</li>
<li>don`t make me think</li>
<li>网页可用性、可访问性、其中的意义</li>
<li>SEO搜索引擎优化，了解搜索引擎的原理</li>
<li>SPA的好处和问题</li>
</ul>
<p>性能优化：</p>
<ul>
<li>减少请求数量（sprite、combo）</li>
<li>善用缓存（application cache、http缓存、CDN、localstorage、sessionstorage，备忘录模式）</li>
<li>减少选择器消耗（从右到左），减少DOM操作（DOM和JavaScript解释器的分离）</li>
<li>CSS的回流与重绘</li>
</ul>
<h5 id="项目">项目</h5><ul>
<li>版本管理：首推Git，用过Git都不会想用SVN了<ul>
<li>Git：本地版本管理的机制</li>
<li>SVN：远程中心的版本管理机制</li>
</ul>
</li>
<li>自动化构建：主要就是less、模板、coffee等的预处理以及对代码压缩和合并<ul>
<li>Gulp：基于流构建，速度快、模块质量好</li>
<li>Grunt：独立任务构建，速度慢，配置蛋疼，灵活性高</li>
</ul>
</li>
<li>预处理和模板引擎<ul>
<li>less：语法简单，但功能有限</li>
<li>jade、ejs、velocity等模板引擎，各有各的长处</li>
<li>coffee：python工程师最爱，我没用过</li>
</ul>
</li>
<li>环境搭建：主要是将线上代码映射到本地，并在本地启动一个demo服务器，至于模拟数据的mock，见仁见智了<ul>
<li>本地代理：ihosts</li>
</ul>
</li>
<li>自动化测试：在业务较为稳定的情况下，可以通过自动化测试来减少测试的事件，但需求较多的时候，维护测试用例的成本会很高，可能用自动化测试会起到反效果<ul>
<li>jasmine</li>
<li>mocha</li>
</ul>
</li>
<li>生态系统<ul>
<li>npm</li>
<li>bower</li>
<li>spm</li>
</ul>
</li>
<li>搭建一个属于自己的博客<ul>
<li>git pages</li>
<li>hexo</li>
<li>jekyll</li>
</ul>
</li>
</ul>
<h5 id="未来">未来</h5><ul>
<li>Web Componets：面向未来的组件化开发方式<ul>
<li>HTML模板</li>
<li>Shadow DOM</li>
<li>Custom Elements</li>
<li>HTML Import</li>
</ul>
</li>
<li>移动端Native开发：这也是需要了解的，以后前端工程师会经常地和webview打交道，也要了解native开发</li>
</ul>
<h5 id="其他">其他</h5><p>有些东西不是考敲码就能弄好的，我参与实习的时候感受到了很多，这些是我遇到的也是我感觉自己做的不好的地方</p>
<ul>
<li><strong>对于业务的思考</strong>：我个人这方面非常欠缺，所以放在最前面，在敲码前要多思考业务</li>
<li>交流和沟通能力：这个非常重要，前端同时需要与项目经理、产品、交互、后台打交道，沟通不善会导致很多无用功，延缓项目</li>
<li>知识管理、时间管理：input和output的平衡，output是最好的input。如何做好分享，参与社区，做好交流，作好记录</li>
<li>对新技术的渴望，以及敢于尝试</li>
</ul>
<h4 id="入门书">入门书</h4><p>入门可以通过啃书，但书本上的东西很多都已经过时了，在啃书的同时，也要持续关注技术的新动态。这里推几本我觉着不错的书：</p>
<ul>
<li>《JavaScript高级编程》：可以作为入门书籍，但同时也是高级书籍，可以快速吸收基础，等到提升再回来重新看</li>
<li>《JavaScript权威指南》：不太适合入门，但是必备，不理解的地方就去查阅一下，很有帮助</li>
<li>《编写可维护的JavaScript》和：</li>
<li>《Node.js开发指南》：不错的Nodejs入门书籍</li>
<li>《深入浅出Node.js》：Nodejs进阶书籍，必备</li>
<li>《JavaScript异步编程》：理解JS异步的编程理念</li>
<li>《JavaScript模式》和《JavaScript设计模式》：JavaScript的代码模式和设计模式，将开发思维转变到JavaScript，非常好的书</li>
<li>《JavaScript框架设计》：在用轮子同时，应当知道轮子是怎么转起来的，讲解很详细，从源码级别讲解框架的各个部分的实现，配合一个现有框架阅读，可以学到很多东西</li>
<li>《Don`t make me think》：网页设计的理念，了解用户行为，非常不错</li>
<li>《CSS禅意花园》：经久不衰的一部著作，同样传递了网页设计中的理念以及设计中需要注意的问题</li>
<li>《高性能JavaScript》和《高性能HTML5》：强调性能的书，其中不只是性能优化，还有很多原理层面的东西值得学习</li>
<li>《HTML5 Canvas核心技术》：我正在读的一本书，对于canvas的使用，动画的实现，以及动画框架的开发都非常有帮助</li>
<li>《HTTP权威指南》：HTTP协议相关必备，前端开发调试的时候也会经常涉及到其中的知识</li>
<li>《响应式Web设计》：技术本身不难，重要的是响应式网页的设计理念，以及移动先行的思想</li>
<li>《JavaScript语言精粹》：老道的书，也是普及JavaScript的开发思维的一本好书，非常适合入门</li>
</ul>
<h4 id="一些不错的网站">一些不错的网站</h4><ul>
<li><a href="https://github.com" target="_blank" rel="external">github</a>：没啥好说的，多阅读别人的源码，多上传自己的源码，向世界各地的大牛学习</li>
<li><a href="http://codepen.io/" target="_blank" rel="external">codepen</a>：感受前端之美的必选之地，里面有很多酷炫的效果和优秀的插件</li>
<li><a href="http://www.echojs.com/" target="_blank" rel="external">echojs</a>：快速了解js新资讯的网站</li>
<li><a href="http://stackoverflow.com/" target="_blank" rel="external">stackoverflow</a>和<a href="segmentfault.com">segmentfault</a>：基本上各种问题都能在上面获得解答</li>
<li><a href="https://developers.google.com/web/fundamentals/" target="_blank" rel="external">google web fundamentals</a>：每篇文章都适合仔细阅读</li>
<li><a href="http://www.staticfile.org/" target="_blank" rel="external">static files</a>：开放的CDN，很好用</li>
<li><a href="http://www.iconfont.cn/" target="_blank" rel="external">iconfont</a>：阿里的矢量图标库，非常不错，支持CDN而且支持项目</li>
<li><a href="http://www.html5rocks.com/" target="_blank" rel="external">html5 rocks</a>: 一个不错的网站，很多浏览器的新特性以及前沿的技术，都能在这上面找到文章</li>
<li><a href="http://css-tricks.com/" target="_blank" rel="external">css tricks</a>：如何活用CSS，以及了解CSS新特性，这里可以满足你</li>
<li><a href="http://bonsaiden.github.io/JavaScript-Garden/zh/#object.general" target="_blank" rel="external">JavaScript 秘密花园</a> JavaScript初学必看，非常不错</li>
<li><a href="http://www.w3cplus.com/" target="_blank" rel="external">w3cplus</a>：一个前端学习的网站，里面的文章质量都挺不错的</li>
<li><a href="http://nodeschool.io/" target="_blank" rel="external">node school</a>：一个不错的node学习网站</li>
<li><a href="http://pcottle.github.io/learnGitBranching/?demo" target="_blank" rel="external">learn git branch</a>：一个git学习网站，交互很棒</li>
<li><a href="http://www.html-js.com/" target="_blank" rel="external">前端乱炖</a>：一个前端文章分享的社区，有很多优秀文章</li>
<li><a href="http://deerchao.net/tutorials/regex/regex.htm" target="_blank" rel="external">正则表达式</a>：一个正则表达式入门教程，非常值得一看</li>
<li><a href="http://www.ruanyifeng.com/blog/" target="_blank" rel="external">阮一峰的博客</a>和<a href="http://www.zhangxinxu.com/wordpress/" target="_blank" rel="external">张鑫旭的博客</a>：快速了解某些知识的捷径，但是如果需要深挖，还需要其他的资源</li>
<li>各路大牛的博客：这个太多了，就不贴了，知乎上有很全的</li>
<li>各种规范的官方网站，不懂得时候读规范</li>
</ul>
<h4 id="历程">历程</h4><p>以前是做Java SSH的，半路出家做的前端，所以水平比较弱，遇到问题也比较多。基本上入门靠看书和<a href="http://www.w3school.com.cn/" target="_blank" rel="external">W3C School</a>上的教程，以及一些前端博客，如<a href="http://www.cnblogs.com/TomXu/" target="_blank" rel="external">汤姆大叔的博客</a>。以前也只是使用jQuery，原生js也没有太多的钻研，后来逐渐看了很多本动物书，比如老道的语言精粹等等。从这些书中学到了很多语言层面的知识。但这显然是不够的，所以我经常会去社区上看看大家在谈论什么，然后去看看相关的资料，感兴趣就会多找些资料看看，或者写一写demo。学CSS主要就是通过这种方式。后来开始更多的关注各路大牛的博客和一些比较深的书籍，以及关注一些新的知识和框架，并且不断地练手提交代码到github，这样也学到了很多知识。在实习的过程中，切身参与到实际项目开发之中，能学到很多在学校学不到的理念和思维，这点也有很大的帮助。不说了，我要去搬砖求offer了…</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近<a href="https://github.com/qiu-deqing">Qiu</a>开了一个<a href="https://github.com/qiu-deqing/FE-learning/blob/master/README.md">FE学习经验介绍</a>，并邀请我去写一点东西。感觉这种方式很有意思，趁着闲下来了，就随便扯了一些，希望能帮到想学前端的同学。我自己只是个前端初学者，希望能有更多的前端爱好者一同学习探讨~~</p>]]>
    
    </summary>
    
      <category term="CSS" scheme="http://lingyu.wang/tags/CSS/"/>
    
      <category term="HTML" scheme="http://lingyu.wang/tags/HTML/"/>
    
      <category term="JavaScript" scheme="http://lingyu.wang/tags/JavaScript/"/>
    
      <category term="思考" scheme="http://lingyu.wang/tags/%E6%80%9D%E8%80%83/"/>
    
      <category term="思考总结" scheme="http://lingyu.wang/categories/%E6%80%9D%E8%80%83%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[细说Generator]]></title>
    <link href="http://lingyu.wang/2014/07/29/generator/"/>
    <id>http://lingyu.wang/2014/07/29/generator/</id>
    <published>2014-07-28T16:00:00.000Z</published>
    <updated>2015-05-31T15:00:49.000Z</updated>
    <content type="html"><![CDATA[<p>好久没写东西了，今天看了下ES6的Generator的相关知识，在这里记录一下。主要内容翻译自规范，并加入了自己的理解和总结</p>
<a id="more"></a>
<p>文章中有很多关于运行时上下文（Execution Context，以下简称EC）的操作，关于EC，作用域链的基础知识请移步<a href="http://lingyu.wang/#/art/blog/2014/03/28/js-basis">JavaScript一些基础知识简介</a></p>
<h1 id="Generator函数">Generator函数</h1><p>generator函数执行的时候，会进行如下动作：</p>
<ol>
<li>创建一个VO，与当前EC（Execution Context，以下简称EC）的作用域链组成新的作用域链</li>
<li>创建一个generator对象，其有如下值：<ul>
<li>Scope：新建的作用域链</li>
<li>Code：generator function内部的代码</li>
<li>ExecutionContext：EC，目前值为null</li>
<li>State：”newborn”</li>
<li>Handler：默认的generator的处理器</li>
</ul>
</li>
</ol>
<p>这里可以看到，Generator函数的执行，函数体内部的代码是不会动的，而是创建一个generator对象，将代码存入其中，并给予相关的上下文</p>
<h1 id="yield的行为">yield的行为</h1><p>当执行到<code>yield e</code>时：</p>
<ol>
<li>计算出表达式e的值</li>
<li>获取当前的EC，并从中获取currentGenerator，也就是yield所在的generator对象</li>
<li>使这个generator对象的ExecutionContext指向当前EC，并将其state修改为suspended</li>
<li>从EC栈弹出当前的EC</li>
<li>返回(normal, 1中的结果值, null)</li>
</ol>
<p>可以看到，yield本身会先获得表达式的值后，将EC从栈顶弹出，交予generator对象。最后会返回一个结构，其含有三个属性，分别为运行结果、计算的结果值和null，Resume在检测到这个结构后，将停止代码的运行</p>
<p>这里yield之后将会返回到当前函数之外，作用域将发生改变，EC栈中的栈顶也会随之改变。而我们在generator function的函数体内部的这个EC，在下一次回来继续执行时依旧需要使用，所以这里就要交给generator对象代为管理一下，等下次回来，将重新压入EC栈的栈顶</p>
<h1 id="return行为">return行为</h1><p>当执行到<code>return e</code>时：</p>
<ol>
<li>计算出表达式e的值</li>
<li>获取当前EC，并从中获取currentGenerator，也就是return所在的generator对象</li>
<li>将这个generator对象的状态修改为closed</li>
<li>创建一个class为StopIteration的新对象，并使其value属性为1中计算的结果值</li>
<li>throw这个对象</li>
</ol>
<p>return也是一样，它同样需要先计算出表达式的值。但之后它获得了generator对象并不是为了做EC栈的维护，而是为了修改generator对象的状态</p>
<h1 id="Generator对象的私有属性">Generator对象的私有属性</h1><ul>
<li>prototype：Object.prototype</li>
<li>code：generator函数的函数体</li>
<li>ExecutionContext：内部代码运行使用的EC</li>
<li>Scope：作用域链</li>
<li>Handler：标准的generator句柄</li>
<li>State：newborn、executing、suspended、closed</li>
<li>Send：看内部方法部分</li>
<li>Throw：看内部方法部分</li>
<li>Close：看内部方法部分</li>
</ul>
<h1 id="外部接口">外部接口</h1><h2 id="next">next</h2><ol>
<li>如果this指向的不是generator对象，抛异常</li>
<li>调用this.send，传入一个undefined</li>
<li>返回结果</li>
</ol>
<p>调用私有send方法</p>
<h2 id="send">send</h2><p>send方法允许指定一个值，作为上一次yield的返回值</p>
<ol>
<li>如果this指向的不是generator对象，抛异常</li>
<li>调用this.send，传入当前第一个参数</li>
<li>返回结果</li>
</ol>
<p>同样是调用私有send方法，不过传入了参数</p>
<h2 id="throw">throw</h2><ol>
<li>如果this指向的不是generator对象，抛异常</li>
<li>调用this.throw，传入当前第一个参数</li>
<li>返回结果</li>
</ol>
<h2 id="close">close</h2><p>调用close方法可以直接以当前的value作为Generator的返回值</p>
<ol>
<li>如果this指向的不是generator对象，抛异常</li>
<li>调用this.close，不传入任何参数</li>
<li>返回结果</li>
</ol>
<h2 id="iterate">iterate</h2><p>由于每个generator对象都是一个iterator对象，直接<code>return this</code>就可以了</p>
<h2 id="小结">小结</h2><p>接口都是内部方法的一层封装，可以看到next和send实际上都是send内部方法的包装</p>
<h1 id="状态定义">状态定义</h1><ul>
<li>newborn：Code不为null，EC为null</li>
<li>executing：Code为null，EC不为null，且generator对象的EC为当前EC</li>
<li>suspended：Code为null，EC不为null，且generator对象的EC不为当前EC</li>
<li>closed：Code为null，EC为null</li>
</ul>
<p>调用了generator function后，生成的generator对象状态即为newborn。也就表明当前generator对象刚刚新建，还没有运行里面的任何代码。同时可以看到EC为null，说明内部运行时的EC并不存在</p>
<p>调用了send方法后，状态会修改为executing，send方法会使用Resume去执行代码，直到遇到yield或者return。遇到yield后，代码停止继续执行，状态修改为suspended，等待下次send。遇到return后，状态将被修改为closed，说明执行完毕。</p>
<p>当然也可以通过close方法，手动修改状态为closed</p>
<h1 id="内部方法">内部方法</h1><h2 id="send方法">send方法</h2><ol>
<li>判断generator对象的state，如果是executing或者closed，就报错。已经在运行了不能重复运行，已经关闭的自然不能运行</li>
<li>如果state为newborn<ol>
<li>将判断传入的参数是否为undefined（外部接口next传入undefined，send则传入给的参数）。这里如果不是undefined，就报错。也就是说刚创建的generator对象不能调用<strong>含有参数的send</strong>外部接口。</li>
<li>创建一个新的EC，这个新的EC的currentGenerator执行这个generator对象，其作用域链为这个generator对象的作用域链</li>
<li>将这个EC压入EC栈中</li>
<li>执行generator中的代码，并返回或得到的结果</li>
</ol>
</li>
<li>能到这，说明state只能是suspended。将state修改为executing，通过Resume(generator的ExecutionContext, normal, 传入的参数)获取结果并返回</li>
</ol>
<p>generator对象的next和send方法的真正实现，其只处理newborn和suspended状态</p>
<p>在newborn状态下，这个generator内部的代码还没有被执行，其内部代码执行时的EC也没有被创建。所以需要创建一个EC并压入EC栈中</p>
<p>而state为suspended就没有这个EC初始化的过程了，内部代码执行时的EC已经在generator的ExecutionContext上了，所以只要修改状态为executing，然后使用Resume执行代码就好</p>
<h2 id="throw-1">throw</h2><ol>
<li>获取generator对象的state，如果为executing或者closed，无法抛异常，报错</li>
<li>如果state为newborn，那么state修改为closed，code修改为null，返回一个包含传入参数的异常</li>
<li>到这里说明state为suspended，修改state为executing，然后通过Resume(generator.ExectionContext, throw, 传入的参数)获得结果，并返回</li>
</ol>
<p>这里如果是suspended，那么需要通过Resume，且completionType为throw来进行抛错</p>
<h2 id="close-1">close</h2><ol>
<li>获取generator对象的state，如果state为executing，那说明代码正在运行，为了防止出现错误，禁止close。</li>
<li>如果state已经是closed了，那直接return就好</li>
<li>如果state为newborn，state修改为closed，code修改为null，然后返回(normal, undefined, null)</li>
<li>如果state为suspended，将其修改为executing，通过Resume(generator.ExecutionContext, return, undefined)获得结果，然后修改状态为closed，返回Resume获得的结果</li>
</ol>
<p>调用close方法可以直接以当前的value作为Generator的返回值，当为newborn时，还没有value，自然是undeinfed。而如果是suspended，就有value了，那么就需要通过Resume，且completionType为return来立即返回</p>
<h2 id="Resume(EC,_completionType,_V)">Resume(EC, completionType, V)</h2><ol>
<li>将这个传入的EC（generator的ExecutionContext）压入到EC栈中</li>
<li>从EC通过currentGenerator获取单签generator对象</li>
<li>设置当前作用域链为当前generator对象的作用域链</li>
<li>继续执行代码，并根据completionType做相应的处理</li>
</ol>
<h1 id="NodeJs上的不同">NodeJs上的不同</h1><p>目前，NodeJs的generator对象上还没有close方法和send方法，但NodeJs中如果next方法传入了参数，行为将和send一样</p>
<h2 id="资料">资料</h2><p><a href="http://wiki.ecmascript.org/doku.php?id=harmony:generators" target="_blank" rel="external">harmony generators ES Wiki</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>好久没写东西了，今天看了下ES6的Generator的相关知识，在这里记录一下。主要内容翻译自规范，并加入了自己的理解和总结</p>]]>
    
    </summary>
    
      <category term="ES6" scheme="http://lingyu.wang/tags/ES6/"/>
    
      <category term="Generator" scheme="http://lingyu.wang/tags/Generator/"/>
    
      <category term="JavaScript" scheme="http://lingyu.wang/tags/JavaScript/"/>
    
      <category term="NodeJs" scheme="http://lingyu.wang/tags/NodeJs/"/>
    
      <category term="NodeJs" scheme="http://lingyu.wang/categories/NodeJs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何写一个KISSY动画插件]]></title>
    <link href="http://lingyu.wang/2014/05/31/kissy-anime-plugin/"/>
    <id>http://lingyu.wang/2014/05/31/kissy-anime-plugin/</id>
    <published>2014-05-30T16:00:00.000Z</published>
    <updated>2015-05-31T15:00:49.000Z</updated>
    <content type="html"><![CDATA[<p>最近写东西写的比较少，并不代表我一直在划水。之前阿里的前辈布置了三个作业，其中一个就是基于KISSY写一个动画插件。事实上，KISSY已经有自己的动画模块，叫做<a href="http://docs.kissyui.com/1.4/docs/html/api/anim/index.html" target="_blank" rel="external">anim</a>，这里前辈的意思就是让我再造一个轮子，<a href="http://lingyucoder.github.io/kissy-anime-plugin/" target="_blank" rel="external">DEMO页面</a>，<a href="https://github.com/LingyuCoder/kissy-anime-plugin" target="_blank" rel="external">Github页面</a></p>
<a id="more"></a>
<p>目前已经有很多比较优秀的JavaScript动画实现了，比如<a href="https://github.com/sole/tween.js/" target="_blank" rel="external">Tween.js</a>，jQuery中的animate就是在Tween的基础上做了一层封装（2.0版本是Tween，老版本的jQuery则是自己实现的动画）。这里多多少少参照了优秀动画模块的思想和内容（比如缓动函数）。</p>
<h2 id="CSS与JavaScript动画对比">CSS与JavaScript动画对比</h2><p>首先需要确定为什么要开发JavaScript的动画模块，毕竟现在已经有CSS3动画了。这里先对比一下CSS动画和JavaScript动画的区别，并从中提炼出我们需要的信息</p>
<h3 id="CSS动画">CSS动画</h3><h4 id="animation">animation</h4><p>CSS3新增了一个<code>animation</code>属性，可以定义动画，相关的属性如下：</p>
<ol>
<li>animation-name：动画的名称，也就是定义的keyframes关键帧的名称</li>
<li>animation-duration：一次动画的时长</li>
<li>animation-timing-funciton：缓动函数，这个后面会有详细介绍</li>
<li>animation-delay：动画延迟时间</li>
<li>animation-iteration-count：动画的播放次数</li>
<li>animation-direction：动画时正向播放还是倒着播放</li>
<li>animation-play-state：动画的状态，暂停还是播放</li>
<li>animation-fill-mode：动画播放时间之外的状态，是否重回动画初始</li>
<li>animation：复合属性，上面属性合在一起的写法</li>
</ol>
<p>可以看到，这里定义了一个动画的整体属性，但并没有定义具体的样式改变。这个任务交给了<code>keyframes</code>去做。也即是说，<code>animation</code>不会单独存在，它总是通过<code>animation-name</code>关联到某个<code>keyframes</code>，这是一个多对一的关系。在<code>keyframes</code>中，具体定义了这个动画哪些样式需要改变，改变多少。</p>
<h4 id="transition">transition</h4><p>另外，还有一个<code>transition</code>属性，可以定义过渡效果，相关属性如下：</p>
<ol>
<li>transition-property：需要参与过渡的属性</li>
<li>transition-duration 过渡的时长</li>
<li>transition-timing-function：过渡的缓动函数</li>
<li>transition-delay：过渡的延时</li>
</ol>
<p><code>transtion</code>定义的是过渡效果，所谓过渡，就是当某个样式改变时，浏览器不会立即赋予这个改变后的值，而是从初始值逐渐改变，平滑的转变成改变后的值。这样也能形成很优秀的动画效果。同时不需要与<code>keyframes</code>结合，可以自己独立存在。</p>
<h4 id="优缺点">优缺点</h4><p>先来说说优点，CSS3的动画的效率要比JavaScript要高，这不是通过优化JavaScript代码就能逆转的。由于CSS3动画作为浏览器渲染引擎实现的一部分，相对于JavaScript动画而言，省去了JavaScript部分，直接由底层语言实现，并且其内部可由浏览器做一系列相关的优化。比如webkit，它可以专门为动画元素创建一个图层，然后将这个元素的样式转变在主线程之外运行。</p>
<p>但是，CSS3动画缺乏足够的控制能力，同时，如果我们动画改变的不是CSS属性（比如滚动，这也是视差滚动必须通过JavaScript实现的原因），CSS3的动画就没辙了。另外，其浏览器的兼容性也是很大问题。毕竟IE从9开始才逐渐开始实现CSS3，如果要在IE6~8中做动画效果，就得另寻他法了</p>
<p>另外，<a href="http://lingyu.wang/#/item">这里</a>有我曾经写过的一些CSS3动画效果</p>
<h3 id="JavaScript动画">JavaScript动画</h3><p>JavaScript的动画，说白了就是每隔一小段时间修改元素的CSS样式。这个间隔时间一般是1000/60ms，也就是说，每秒钟该60次，达到一秒60帧的效果。每次修改，大致需要经过如下流程：</p>
<ol>
<li>计算当前元素样式</li>
<li>修改元素样式</li>
<li>重绘元素</li>
</ol>
<p>前两部都是通过JavaScript完成，这也意味着，它不精确。如我们所知，JavaScript的定时函数<code>setTimeout</code>和<code>setInterval</code>本来就不是很精确（现在可以使用requestAnimationFrame，但老版本IE不兼容），而JavaScript运行在主线程——UI线程上，上面运行的其他任务（样式计算、布局、绘制、其他JavaScript代码等）都可能造成线程的阻塞。这也是JavaScript动画的最大弊病。</p>
<p>但JavaScript本身，拥有强大的控制能力，它可以随心所欲的控制动画，开始、暂停、倒放、中止、回放、单帧等等，这些JavaScript都能搞定。而像CSS动画无法做的滚动效果，JavaScript也可以轻松实现。而且，我们可以将动画扩展到IE 6~8上（当然transform还是不兼容）。</p>
<h2 id="需求分析">需求分析</h2><h3 id="动画属性">动画属性</h3><p>通过参考CSS动画实现，我们也可以很容易的确定，通过实现JavaScript实现动画时，动画应该具备的属性：</p>
<ol>
<li>涉及的元素（elems）</li>
<li>需要改变的样式（styles）</li>
<li>时长（duration）</li>
<li>缓动函数（easing-function）</li>
<li>播放次数（times）</li>
</ol>
<h3 id="动画控制">动画控制</h3><p>而控制上，我们应该实现的功能：</p>
<ol>
<li>开始（run）</li>
<li>暂停（pause）</li>
<li>暂停恢复（resume）</li>
<li>中止（stop）</li>
<li>倒放（reverse）</li>
<li>单帧（go）</li>
</ol>
<h3 id="动画能够改变的内容">动画能够改变的内容</h3><p>需要能够改变的内容有：</p>
<ol>
<li>CSS样式</li>
<li>滚动</li>
</ol>
<h2 id="动画对象">动画对象</h2><p>如之前所说，JavaScript动画，实际上就是每隔一小段时间改变元素的样式。我们可以把动画看做一个对象，其内部有这个动画相关的元素、动画的属性，并提供一系列的接口控制这个动画</p>
<p>所以，动画的对象大致上是这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Anime</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Anime.prototype.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">Anime.prototype.pause = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">Anime.prototype.resume = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">Anime.prototype.stop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">Anime.prototype.go = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>而倒放是事先定义好的，我们可以作为动画属性传入</p>
<p>动画最终要的，就是参与动画的元素，和需要被改变的样式及其目标值。这两者，我们是没办法通过给默认值的形式来省略的。其他的，我们可以通过给一些默认值来简化API，所以将接口设计成如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Anime</span>(<span class="params">elems, styles, config</span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>conifg是一个对象，剩下的可选属性都在其中定义，通过mixin的方式加入到动画对象中，还可以提供一些默认值：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> defaultConfig = &#123;</span><br><span class="line">    callback: noop,</span><br><span class="line">    duration: <span class="number">1500</span>,</span><br><span class="line">    reverse: <span class="literal">false</span>,</span><br><span class="line">    easing: <span class="string">"linear"</span>,</span><br><span class="line">    times: <span class="number">1</span>,</span><br><span class="line">    spend: <span class="number">0</span>,</span><br><span class="line">    state: <span class="string">"running"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这里还加了一些其他属性，比如spend和state，spend实际上就是当前动画运行了多长时间，state则是动画对象当前的状态，是播放中（running），还是暂停（paused），还是结束（ended）。state结合控制来做的话，就是一个状态机：</p>
<ul>
<li>running为初始状态，可以通过pause方法，转到paused状态，也可以通过stop方法，转到ended状态</li>
<li>paused为暂停状态，通过resume方法，转到running状态，也可以通过stop转到ended状态</li>
<li>ended为终止状态，可以通过run放法进行重放，转到running状态</li>
</ul>
<h2 id="动画队列">动画队列</h2><p>光有动画对象是不够的，我们需要对所有的动画对象进行处理，获取其中running状态的对象，每隔一小段时间，修改其状态，并绘制到页面上。这里就需要一个动画队列了，实际上也就是一个数组，里面的每个元素都是状态为running的动画对象。每隔1000/60ms就遍历一遍这个数组，更新每一个动画对象的状态，并进行绘制。</p>
<p>需要注意的地方是，队列中只有running状态的对象，也就是说，如果队列中没有元素，那么就不需要每隔一段时间去遍历了。另外，如果有动画运行结束，变成不是running状态，那么需要从动画队列中移除</p>
<p>所以，队列首先得实现相关的添加删除操作，注意去重：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> animeQueue = [];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addAnime</span>(<span class="params">anime</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.indexOf(anime, animeQueue) === -<span class="number">1</span>) &#123;</span><br><span class="line">        animeQueue.push(anime);</span><br><span class="line">        checkRunning();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteAnime</span>(<span class="params">anime</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> index = S.indexOf(anime, animeQueue);</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        animeQueue.splice(index, <span class="number">1</span>);</span><br><span class="line">        checkRunning();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后，还有一个心跳函数，用于每隔一段时间遍历动画队列：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pulse</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> deleteIndex = [],</span><br><span class="line">        i, m, tmp;</span><br><span class="line">    <span class="keyword">if</span> (running) &#123;</span><br><span class="line">        S.each(animeQueue, <span class="function"><span class="keyword">function</span>(<span class="params">anime, index</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (anime.state === <span class="string">"running"</span>) &#123;</span><br><span class="line">                anime.go();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                deleteIndex.push(index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (i = deleteIndex.length; i--;) &#123;</span><br><span class="line">            animeQueue.splice(deleteIndex[i], <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        dealing = <span class="literal">false</span>;</span><br><span class="line">        checkRunning();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>checkRunning函数，来决定下一帧，是否需要运行，如果队列中没有动画对象了，自然不需要运行了，否则就要继续遍历动画队列：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkRunning</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (animeQueue.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        running = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!dealing) &#123;</span><br><span class="line">            dealing = <span class="literal">true</span>;</span><br><span class="line">            requestAnimationFrame(pulse);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        running = <span class="literal">false</span>;</span><br><span class="line">        dealing = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="缓动函数">缓动函数</h2><p>缓动函数的说明和教程网上还是比较多的，说白了就是一个进度的映射。一般都是使用一些现有的缓动函数，我直接从Tween中把它的缓动函数扒了出来…</p>
<h2 id="样式处理">样式处理</h2><p>动画可以理解为三个问题，从什么地方开始，经过什么样的过程，到什么地方去。我们可以通过构建动画对象时传入的styles来确定需要修改的样式，以及样式动画最终的目标值。这个目标值可以是绝对的，比如<code>width: 400px</code>，就是要修改宽度到400像素，但也可以相对的，比如<code>width: +=200px</code>，在原有基础上增大200像素的宽度。我们需要确定元素样式的起始值、绝对的目标值，才能算出某个时间点的中间值，并将中间值赋予给元素。所以，样式的处理应该包括四个部分：</p>
<ol>
<li>从元素获取样式的起始值（从什么地方开始）</li>
<li>获取样式的绝对目标值，如果传入的是相对值，那么需要通过起始值来计算的处绝对目标值（到什么地方去）</li>
<li>计算当前时间点的中间值（经过怎样的过程）</li>
<li>向元素赋予计算出来的中间值（经过怎样的过程）</li>
</ol>
<p>后两个一个是计算，一个是展示，都属于过程内容。可以把这四个部分抽象成四个方法，分别是获取、解析、计算、赋值：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCSS</span>(<span class="params">elem, style</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> val;</span><br><span class="line">    <span class="keyword">if</span> (hooks[style] &amp;&amp; hooks[style].get) &#123;</span><br><span class="line">        val = hooks[style].get(elem, style);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val = hooks._default.get(elem, style);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parseCSS(val, style);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseCSS</span>(<span class="params">val, style, from</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hooks[style] &amp;&amp; hooks[style].parse) &#123;</span><br><span class="line">        <span class="keyword">return</span> hooks[style].parse(val, from);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hooks._default.parse(val, from);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">computeCSS</span>(<span class="params">style, from, to, pos</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hooks[style] &amp;&amp; hooks[style].compute) &#123;</span><br><span class="line">        <span class="keyword">return</span> hooks[style].compute(from, to, pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hooks._default.compute(from, to, pos);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assignCSS</span>(<span class="params">elem, style, val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hooks[style] &amp;&amp; hooks[style].assign) &#123;</span><br><span class="line">        <span class="keyword">return</span> hooks[style].assign(elem, style, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hooks._default.assign(elem, style, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里，可以看到很多hooks，阅读过jQuery源码的不会对这种方式陌生。钩子是为特别样式提供特别处理，如果不需要通过钩子进行处理，直接使用_default提供的默认处理方式就行了</p>
<h2 id="特殊处理">特殊处理</h2><p>一般的属性，可以通过<code>Dom.css</code>很轻松的获取起始值并计算出绝对目标值，但有一些则不然，这里列三个特例</p>
<h3 id="颜色属性">颜色属性</h3><p>如color、background等，这些我们应该为其提供渐变，但无论是用户传入的目标值，还是获取到的值，都有好几个形式：</p>
<ol>
<li>HEX：<code>#fff</code>或<code>#f0f0f0</code></li>
<li>RGB：<code>rgb(245, 28, 33)</code></li>
<li>RGBA：<code>rgba(245, 28, 33, .6)</code></li>
<li>直接名称：<code>red</code>、<code>white</code>等等</li>
<li>HSL和HSLA，这里不做实现</li>
</ol>
<h4 id="获取">获取</h4><p>获取和一般CSS属性没差， 直接使用默认方式了</p>
<h4 id="解析">解析</h4><p>一般，是统一将其解析成RGBA的形式来做，如果不支持RGBA的浏览器，解析成RGB。这样我们就拥有了两个三个元素（RGB）或四个元素的数组（RGBA），一个数组为起始值，一个数组为目标值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseColor</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    val = val.replace(rClearSpace, <span class="string">""</span>).toLowerCase();</span><br><span class="line">    <span class="keyword">if</span> (normalColors[val]) &#123;</span><br><span class="line">        <span class="keyword">return</span> normalColors[val];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> color = [];</span><br><span class="line">    <span class="keyword">var</span> tmp;</span><br><span class="line">    <span class="keyword">var</span> i;</span><br><span class="line">    <span class="keyword">if</span> (rHexColor.test(val)) &#123;</span><br><span class="line">        tmp = [];</span><br><span class="line">        <span class="keyword">if</span> (val.length === <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">3</span>; i--;) &#123;</span><br><span class="line">                tmp[i] = val.charAt(i + <span class="number">1</span>);</span><br><span class="line">                tmp[i] += tmp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val.length === <span class="number">7</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">3</span>; i--;) &#123;</span><br><span class="line">                tmp[i] = val.substr(<span class="number">1</span> + i * <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">3</span>; i--;) &#123;</span><br><span class="line">            color[i] = <span class="built_in">parseInt</span>(tmp[i], <span class="number">16</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        color[<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!S.isNull(tmp = val.match(rRGB))) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">3</span>; i--;) &#123;</span><br><span class="line">            color[i] = <span class="built_in">parseInt</span>(tmp[i + <span class="number">1</span>], <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        color[<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!S.isNull(tmp = val.match(rRGBA))) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">4</span>; i--;) &#123;</span><br><span class="line">            color[i] = <span class="built_in">Number</span>(tmp[i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="计算">计算</h4><p>计算中间值的过程则是对颜色数组中的每一个元素（R或G或B或A）计算一下中间值就行了<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">computeColor</span>(<span class="params">from, to, pos</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _default = hooks._default,</span><br><span class="line">        result = [],</span><br><span class="line">        i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">2</span>; i++) &#123;</span><br><span class="line">        result.push(<span class="built_in">parseInt</span>(_default.compute(from[i], to[i], pos), <span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    result.push(_default.compute(from[<span class="number">3</span>], to[<span class="number">3</span>], pos));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="赋值">赋值</h4><p>赋值的时候，我们需要将数组恢复成CSS中的方式，也就是恢复成RGB或RGBA的方式<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assignColor</span>(<span class="params">elem, style, val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(KISSY.Features.isIELessThan(<span class="number">9</span>))&#123;</span><br><span class="line">        Dom.css(elem, style, <span class="string">"rgb("</span> + val.slice(<span class="number">0</span>, <span class="number">3</span>).join(<span class="string">","</span>) + <span class="string">")"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Dom.css(elem, style, <span class="string">"rgba("</span> + val.join(<span class="string">","</span>) + <span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="滚动">滚动</h3><h4 id="获取-1">获取</h4><p>滚动并不属于CSS属性，但我们经常会使用，比如滚动到页首。KISSY本身提供了包装，可以获取当前滚动的高度</p>
<h4 id="解析-1">解析</h4><p>通过KISSY获取的滚动属性值无需解析，可以使用默认解析</p>
<h4 id="计算-1">计算</h4><p>计算过程也是，使用默认计算即可</p>
<h4 id="赋值-1">赋值</h4><p>赋值过程就和一般的CSS属性不一样了，使用KISSY提供的接口进行赋值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">S.each(<span class="string">"scrollTop scrollLeft"</span>.split(<span class="string">" "</span>), <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _default = hooks._default;</span><br><span class="line">    hooks[type] = &#123;</span><br><span class="line">        assign: <span class="function"><span class="keyword">function</span>(<span class="params">elem, style, val</span>) </span>&#123;</span><br><span class="line">            Dom[type](elem, val);</span><br><span class="line">        &#125;,</span><br><span class="line">        get: <span class="function"><span class="keyword">function</span>(<span class="params">elem, style</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Dom[type](elem);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="transform">transform</h3><p><strong>这里只处理了2D的transform</strong></p>
<p>transform的值也有很多不同的形式：</p>
<ol>
<li>matrix</li>
<li>rotate</li>
<li>translate、translateX、translateY</li>
<li>scale、scaleX、scaleY</li>
<li>skew、skewX、skewY</li>
</ol>
<h4 id="获取-2">获取</h4><p>获取的过程和一般CSS元素获取的过程没有差别，使用默认的方式就好</p>
<h4 id="解析-2">解析</h4><p>这里就比较麻烦了，需要处理所有的情况，我们将所有的情况转变成如下的结构：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = &#123;</span><br><span class="line">    translateX: <span class="number">0</span>,</span><br><span class="line">    translateY: <span class="number">0</span>,</span><br><span class="line">    rotate: <span class="number">0</span>,</span><br><span class="line">    skewX: <span class="number">0</span>,</span><br><span class="line">    skewY: <span class="number">0</span>,</span><br><span class="line">    scaleX: <span class="number">1</span>,</span><br><span class="line">    scaleY: <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>代码较长</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decomposeMatrix</span>(<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scaleX, scaleY, skew,</span><br><span class="line">        A = matrix[<span class="number">0</span>],</span><br><span class="line">        B = matrix[<span class="number">1</span>],</span><br><span class="line">        C = matrix[<span class="number">2</span>],</span><br><span class="line">        D = matrix[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure matrix is not singular</span></span><br><span class="line">    <span class="keyword">if</span> (A * D - B * C) &#123;</span><br><span class="line">        scaleX = <span class="built_in">Math</span>.sqrt(A * A + B * B);</span><br><span class="line">        skew = (A * C + B * D) / (A * D - C * B);</span><br><span class="line">        scaleY = (A * D - B * C) / scaleX;</span><br><span class="line">        <span class="comment">// step (6)</span></span><br><span class="line">        <span class="keyword">if</span> (A * D &lt; B * C) &#123;</span><br><span class="line">            skew = -skew;</span><br><span class="line">            scaleX = -scaleX;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// matrix is singular and cannot be interpolated</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// In this case the elem shouldn't be rendered, hence scale == 0</span></span><br><span class="line">        scaleX = scaleY = skew = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The recomposition order is very important</span></span><br><span class="line">    <span class="comment">// see http://hg.mozilla.org/mozilla-central/file/7cb3e9795d04/layout/style/nsStyleAnimation.cpp#l971</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        translateX: myParse(matrix[<span class="number">4</span>]),</span><br><span class="line">        translateY: myParse(matrix[<span class="number">5</span>]),</span><br><span class="line">        rotate: myParse(<span class="built_in">Math</span>.atan2(B, A) * <span class="number">180</span> / <span class="built_in">Math</span>.PI),</span><br><span class="line">        skewX: myParse(<span class="built_in">Math</span>.atan(skew) * <span class="number">180</span> / <span class="built_in">Math</span>.PI),</span><br><span class="line">        skewY: <span class="number">0</span>,</span><br><span class="line">        scaleX: myParse(scaleX),</span><br><span class="line">        scaleY: myParse(scaleY)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">valueStringToArray</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = val.split(<span class="string">","</span>);</span><br><span class="line">    result = S.map(result, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> myParse(value);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseTransform</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = &#123;</span><br><span class="line">        translateX: <span class="number">0</span>,</span><br><span class="line">        translateY: <span class="number">0</span>,</span><br><span class="line">        rotate: <span class="number">0</span>,</span><br><span class="line">        skewX: <span class="number">0</span>,</span><br><span class="line">        skewY: <span class="number">0</span>,</span><br><span class="line">        scaleX: <span class="number">1</span>,</span><br><span class="line">        scaleY: <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> value;</span><br><span class="line">    <span class="keyword">var</span> regResult;</span><br><span class="line">    <span class="keyword">var</span> i, j, m;</span><br><span class="line">    <span class="keyword">var</span> name;</span><br><span class="line">    <span class="keyword">var</span> strs;</span><br><span class="line">    strs = val.replace(rClearSpace, <span class="string">""</span>).split(<span class="string">")"</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, m = strs.length; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!strs[i] || strs[i] === <span class="string">"none"</span>) <span class="keyword">continue</span>;</span><br><span class="line">        regResult = strs[i].split(<span class="string">"("</span>);</span><br><span class="line">        name = regResult[<span class="number">0</span>];</span><br><span class="line">        value = valueStringToArray(regResult[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">switch</span> (name) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"matrix"</span>:</span><br><span class="line">                result = decomposeMatrix(value);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"translate"</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"skew"</span>:</span><br><span class="line">                result[name + <span class="string">"X"</span>] = value[<span class="number">0</span>] || <span class="number">0</span>;</span><br><span class="line">                result[name + <span class="string">"Y"</span>] = value[<span class="number">1</span>] || <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"scale"</span>:</span><br><span class="line">                result[name + <span class="string">"X"</span>] = value[<span class="number">0</span>] || <span class="number">0</span>;</span><br><span class="line">                result[name + <span class="string">"Y"</span>] = value[<span class="number">1</span>] || result[name + <span class="string">"X"</span>];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"translateX"</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"translateY"</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"scaleX"</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"scaleY"</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"skewX"</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"skewY"</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"rotate"</span>:</span><br><span class="line">                result[name] = value[<span class="number">0</span>] || <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这其中decomposeMatrix函数来自KISSY，将matrix转换成变换属性的形式。</p>
<h4 id="计算-2">计算</h4><p>获取到上面的结构后，只需要对其中的每一项计算中间值就可以了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">computeTransform</span>(<span class="params">from, to, pos</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _default = hooks._default;</span><br><span class="line">    <span class="keyword">var</span> result = &#123;&#125;;</span><br><span class="line">    S.each(to, <span class="function"><span class="keyword">function</span>(<span class="params">value, key</span>) </span>&#123;</span><br><span class="line">        result[key] = _default.compute(from[key], to[key], pos);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="赋值-2">赋值</h3><p>赋值也是一样，将上面的结构一一提取合并，组成一个字符串，另外需要注意添加上相应的单位：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assignTransform</span>(<span class="params">elem, style, val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> valueArray = [];</span><br><span class="line">    S.each(val, <span class="function"><span class="keyword">function</span>(<span class="params">value, key</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((key.indexOf(<span class="string">"scale"</span>) &gt; -<span class="number">1</span> &amp;&amp; value === <span class="number">1</span>) || (key.indexOf(<span class="string">"scale"</span>) === -<span class="number">1</span> &amp;&amp; value === <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (key === <span class="string">"rotate"</span> || key.indexOf(<span class="string">"skew"</span>) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">            value += <span class="string">"deg"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.indexOf(<span class="string">"translate"</span>) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">            value += <span class="string">"px"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        valueArray.push(key + <span class="string">"("</span> + value + <span class="string">")"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    Dom.css(elem, style, valueArray.join(<span class="string">" "</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="总结">总结</h2><p>这是一次造轮子实验，效果还是出来了，基本的动画都能完成，且兼容IE 6，transform部分兼容到IE 9，虽然不可能直接替代KISSY的anim模块，但用起来也不算差，毕竟兼容问题都让KISSY去做了。毕竟这只是个作业，中间搞搞停停弄了3天，之后就是写DEMO之类的。后面打算优化一下代码</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近写东西写的比较少，并不代表我一直在划水。之前阿里的前辈布置了三个作业，其中一个就是基于KISSY写一个动画插件。事实上，KISSY已经有自己的动画模块，叫做<a href="http://docs.kissyui.com/1.4/docs/html/api/anim/index.html">anim</a>，这里前辈的意思就是让我再造一个轮子，<a href="http://lingyucoder.github.io/kissy-anime-plugin/">DEMO页面</a>，<a href="https://github.com/LingyuCoder/kissy-anime-plugin">Github页面</a></p>]]>
    
    </summary>
    
      <category term="CSS" scheme="http://lingyu.wang/tags/CSS/"/>
    
      <category term="HTML" scheme="http://lingyu.wang/tags/HTML/"/>
    
      <category term="JavaScript" scheme="http://lingyu.wang/tags/JavaScript/"/>
    
      <category term="Kissy" scheme="http://lingyu.wang/tags/Kissy/"/>
    
      <category term="动画" scheme="http://lingyu.wang/tags/%E5%8A%A8%E7%94%BB/"/>
    
      <category term="前端综合" scheme="http://lingyu.wang/categories/%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[WebRTC的RTCDataChannel]]></title>
    <link href="http://lingyu.wang/2014/05/22/webrtc-data-channels/"/>
    <id>http://lingyu.wang/2014/05/22/webrtc-data-channels/</id>
    <published>2014-05-21T16:00:00.000Z</published>
    <updated>2015-05-31T15:00:49.000Z</updated>
    <content type="html"><![CDATA[<p>在两个浏览器中，为聊天、游戏、或是文件传输等需求发送信息是十分复杂的。通常情况下，我们需要建立一台服务器来转发数据，当然规模比较大的情况下，会扩展成多个数据中心。这种情况下很容易出现很高的延迟，同时难以保证数据的私密性。</p>
<p>这些问题可以通过WebRTC提供的RTCDataChannel API来解决，他能直接在点对点之间传输数据。这篇文章将介绍如何创建并使用数据通道，并提供了一些网络上常见的用例</p>
<a id="more"></a>
<blockquote>
<p>为了充分理解这篇文章，你可能需要去了解一些RTCPeerConnection API的相关知识，以及STUN，TURN、信道如何工作。强烈推荐<a href="http://www.html5rocks.com/en/tutorials/webrtc/basics/" target="_blank" rel="external">Getting Started With WebRTC</a>这篇文章</p>
</blockquote>
<h3 id="为什么我们需要另外一个数据通道">为什么我们需要另外一个数据通道</h3><p>我们已经有<a href="http://www.html5rocks.com/en/tutorials/websockets/basics/" target="_blank" rel="external">WebSocket</a>、<a href="http://www.html5rocks.com/en/tutorials/file/xhr2/" target="_blank" rel="external">AJAX</a>和<a href="http://www.html5rocks.com/en/tutorials/eventsource/basics/" target="_blank" rel="external">服务器发送事件</a>了，为什么我们需要另外一个通信信道？WebSocket是全双工的，但这些技术的设计都是让浏览器与服务器之间进行通信。</p>
<p>RTCDataChannel则是一个完全不同的途径：</p>
<ul>
<li>它通过RTCPeerConnection API，可以建立点对点互联。由于不需要中介服务器，中间的“跳数”减少，延迟更低。</li>
<li>RTCDataChannel使用<a href="https://en.wikipedia.org/wiki/Stream_Control_Transmission_Protocol#Features" target="_blank" rel="external">Stream Control Transmission Protocol</a>(SCTP)协议，允许我们配置传递语义：我们可以配置包传输的顺序并提供重传时的一些配置。</li>
</ul>
<p>基于SCTP的支持的RTCDataChannel已经能够在桌面的Chrome、Opera和Firefox中使用，移动端则有Android支持。</p>
<h3 id="一个警告：信令、STUN和TURN">一个警告：信令、STUN和TURN</h3><p>尽管WebRTC允许点对点的通信，但它依然需要服务器：</p>
<ul>
<li>信令传输：建立点对点的连接需要传输一些媒体和网络相关的元数据信息，需要通过服务器</li>
<li>NAT和防火墙穿透：我们需要通过ICE框架来建立点与点之间的网络路径。可以使用STUN服务器（确定双方的可公开访问你的IP地址和端口）以及TURN服务器（如果直接连接失败，就必须数据中继了）</li>
</ul>
<p><a href="http://www.html5rocks.com/en/tutorials/webrtc/infrastructure/" target="_blank" rel="external">WebRTC in the real world: STUN, TURN, and signaling</a> 文章详细介绍了WebRTC如何与这两种服务器进行交互</p>
<h3 id="功能">功能</h3><p>RTCDataChannel API支持灵活的数据类型。它的API是模仿WebSocket设计的，并且支持JavaScript中的二进制类型如Blob、ArrayBuffer和ArrayBufferView，另外还支持字符串。这些类型对于文件传输和多玩家的游戏来说意义重大。</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-22/1.png" alt="TCP、UDP、SCTP提供的功能"><br>以上来自<a href="http://www.igvita.com/" target="_blank" rel="external">Ilya Grigorik</a>的<a href="http://chimera.labs.oreilly.com/books/1230000000545/ch18.html" target="_blank" rel="external">High Performance Browser Networking</a></p>
<p>RTCDataChannel在不可靠模式（类似于UDP）或可靠模式（类似于TCP）下都能够正常工作。但这两种模式有一些不同：</p>
<ul>
<li>可靠模式：保证消息传输一定成功，并保证按序到达。这自然需要一定量的开销，速度也更慢</li>
<li>不可靠模式：不保证消息传输一定成功，也不保证按序到达。这消除了那些开销，速度也更快</li>
</ul>
<p>在不会丢包的情况下，这两种模式的效率差不多。然而，可靠模式下，丢包将造成后续的所有包阻塞，丢失的数据包也将重传直至其成功到达。当然，我们能在同一个应用中使用多个数据通道，每一个有他们自己的可靠性</p>
<p>下面将说明如何去配置可靠模式或不可靠模式的RTCDataChannel</p>
<h3 id="配置数据通道">配置数据通道</h3><p>网上已经有很多RTCDataChannel的例子了：</p>
<ul>
<li><a href="http://simpl.info/dc" target="_blank" rel="external">simpl.info/dc</a></li>
<li><a href="http://googlechrome.github.io/webrtc/dc1.html" target="_blank" rel="external">googlechrome.github.io/webrtc/dc1.html</a>(SCTP或者RTP)</li>
<li><a href="http://pubnub.github.io/webrtc" target="_blank" rel="external">pubnub.github.io/webrtc</a>(两个PubNub用户)</li>
</ul>
<p>ps：PubBub是一个实时信息通讯应用开发公司</p>
<p>在这个例子中，浏览器创建了一个对等连接连接到自己。然后在这个对等连接n上创建了一个数据通道，发送了一些消息。最后，消息成功抵达并显示在页面上。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> peerConnection = <span class="keyword">new</span> RTCPeerConnection();</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用信令传输信道创建对等连接</span></span><br><span class="line"><span class="keyword">var</span> dataChannel =</span><br><span class="line">  peerConnection.createDataChannel(<span class="string">"myLabel"</span>, dataChannelOptions);</span><br><span class="line"></span><br><span class="line">dataChannel.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Data Channel Error:"</span>, error);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">dataChannel.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Got Data Channel Message:"</span>, event.data);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">dataChannel.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  dataChannel.send(<span class="string">"Hello World!"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">dataChannel.onclose = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"The Data Channel is Closed"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>dataChannel</code>对象建立在一个已经创建完毕的对等连接之上。它可以创建在信令传输前后。另外，可以赋予一个label来作区分，并提供一系列的配置选项：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dataChannelOptions = &#123;</span><br><span class="line">  ordered: <span class="literal">false</span>, <span class="comment">//不保证到达顺序</span></span><br><span class="line">  maxRetransmitTime: <span class="number">3000</span>, <span class="comment">//最大重传时间</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们可以加入一个<code>maxRetransimits</code>选项（最大重传次数），但<code>maxRetransimitTime</code>或<code>maxRetransimits</code>只能设定一个，不能两个懂事设定。如果想使用UDP的方式，设定<code>maxRetransmits</code>为0，<code>ordered</code>为<code>false</code>。如果想要获取更多信息，请查看<a href="http://tools.ietf.org/html/rfc4960" target="_blank" rel="external">RFC 4960</a>（SCTP）和<a href="http://tools.ietf.org/html/rfc3758" target="_blank" rel="external">RFC 3758</a>（SCTP部分可靠性）</p>
<ul>
<li>ordered: 数据通道是否保证按序传输数据</li>
<li>maxRetrasmitTime：在信息失败前的最大重传时间（强迫进入不可靠模式）</li>
<li>maxRetransmits：在信息失败前的最大重传次数（强迫进入不可靠模式）</li>
<li>protocol：允许使用一个自协议，但如果协议不支持，将会失败</li>
<li>negotiated：如果设为true，将一处对方的数据通道的自动设置，也就是说，将使用相同的id以自己配置的方式与对方建立数据通道</li>
<li>id：为数据通道提供一个自己定义的ID</li>
</ul>
<h3 id="它安全吗？">它安全吗？</h3><p>在WebRTC所有的组件中，都会强制进行加密。在RTCDataChannel中，所有的数据都使用<a href="https://en.wikipedia.org/wiki/Datagram_Transport_Layer_Security" target="_blank" rel="external">数据报传输层安全性</a>（DTLS）。DTLS是SSL的衍生，也就是说，你的数据将和使用基于SSL的连接一样安全。DTLS已经被标准化，并内置于所有支持WebRTC的浏览器中。如果需要更多关于DTLS信息，请访问<a href="http://wiki.wireshark.org/DTLS" target="_blank" rel="external">Wireshark的维基</a></p>
<h3 id="改变你考虑数据的方式">改变你考虑数据的方式</h3><p>处理大批量的数据，一直是JavaScript的一个难点。正如<a href="http://www.sharefest.me/" target="_blank" rel="external">Sharefest</a>所提出的观点，我们需要用一种新的方式来考虑数据。如果你需要传输一个比你当前可用内存更大的文件，就必须考虑新的保存信息的方式了。这也就是像<a href="http://www.html5rocks.com/en/tutorials/file/filesystem/" target="_blank" rel="external">FileSystem API</a>等技术存在的意义。我们将在下面进行介绍</p>
<h3 id="搭建一个文件共享应用">搭建一个文件共享应用</h3><p>现在我们可以通过RTCDataChannel来创建文件共享应用。将应用建立在RTCDataChannel智商也意味着传输的文件数据都将加密，而且不会经过应用的服务器端。通过这个功能，我们能够实现多用户之间的互联，进行文件共享。</p>
<p>需要成功传输一个文件，我们需要如下几步：</p>
<ol>
<li><a href="http://www.html5rocks.com/en/tutorials/file/dndfiles/" target="_blank" rel="external">通过JavaScript的File API读取文件数据</a></li>
<li>使用RTCPeerConnection在用户间创建一个对等连接</li>
<li>使用RTCDataChannel在用户间创建一个数据通道</li>
</ol>
<p>在使用RTCDataChannel时，还有一些其他问题需要考虑：</p>
<ul>
<li><strong>文件大小</strong>：如果文件很小，能够直接通过一个Blob进行存储和读取，那么我们可以直接使用File API将其读进内存，并通过可靠的数据通道发送（但是需要注意的是，浏览器有最大传输大小的限制）。随着文件变大的话，就不那么简单了。我们需要一个分块机制：文件将分成多个碎片，称为文件块。我们不再直接发送整个文件，而是一次发送一个文件块。当然文件块上会有一些元数据如块的ID，方便对方能够识别。接收到文件块之后，首先将这些文件块保存在离线存储中（例如，使用FileSystem API），只有当所有块都接收完毕，才将其拼合起来成为完整的文件，保存到用户的硬盘。</li>
<li><strong>速度</strong>：文件传输更适合使用可靠模式（像TCP）还是非可靠模式（像UDP）还有待商榷。如果应用知识简单的一对一文件传输，使用不可靠的数据通道将需要设计一定的响应/重传协议。你必须自己来实现它，就算你非常优秀，它仍然不会比使用可靠的数据传输快多少。可靠而无序的数据通道将会更加合适，但是如果是多方文件传输，结果可能会有所不同。</li>
<li><strong>块大小</strong>：这些是你的应用中的最小的“原子”数据。目前有传输大小限制（尽管以后可能不会有限制），所以必须要进行分块。目前建议的最大块大小为16KB。</li>
</ul>
<p>如果文件已经被完全传输，就可以使用一个a标签提供下载了：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">saveFile</span>(<span class="params">blob</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> link = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</span><br><span class="line">  link.href = <span class="built_in">window</span>.URL.createObjectURL(blob);</span><br><span class="line">  link.download = <span class="string">'File Name'</span>;</span><br><span class="line">  link.click();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>目前已经有两个文件共享的应用使用了这种方式：<a href="http://pubnub.github.io/rtc-pubnub-fileshare/" target="_blank" rel="external">pubnub.github.io/rtc-pubnub-fileshare</a>和<a href="https://github.com/Peer5/ShareFest" target="_blank" rel="external">github.com/Peer5/ShareFest</a>，这两个应用都是开源的，并提供了基于RTCDataChannel的文件共享</p>
<h3 id="那么我们能做什么？">那么我们能做什么？</h3><p>RTCDataChannel为文件共享、多人游戏以及内容交付应用提供了全新的实现思路：</p>
<ul>
<li>上面已经提到了点对点的文件传输了</li>
<li>多人游戏，与诸如WebGL等其他技术相结合，比如Mozilla的<a href="https://hacks.mozilla.org/2013/03/webrtc-data-channels-for-great-multiplayer/" target="_blank" rel="external">Banana Bread</a></li>
<li>内容交付：由<a href="https://peercdn.com/" target="_blank" rel="external">PeerCDN</a>重新改造的一个用于提供点对点通信提供资源的框架</li>
</ul>
<h3 id="改变你构建应用的方式">改变你构建应用的方式</h3><p>现在我们可使用高新能、低延迟的RTCDataChannel来创建更优秀的应用了。一些框架，诸如<a href="http://peerjs.com/" target="_blank" rel="external">PeerJS</a>和<a href="https://github.com/pubnub/webrtc" target="_blank" rel="external">PubNub WebRTC SDK</a>，使得RTCDataChannel更加易于使用，其API也被各个平台所支持</p>
<p>RTCDataChannel所带来的优势能够改变你在浏览器中传输数据的观念。</p>
<h3 id="更多资讯">更多资讯</h3><ul>
<li><a href="http://www.html5rocks.com/en/tutorials/webrtc/basics/" target="_blank" rel="external">Getting started with WebRTC</a></li>
<li><a href="http://www.html5rocks.com/en/tutorials/webrtc/infrastructure/" target="_blank" rel="external">WebRTC in the real world: STUN, TURN and signaling</a></li>
<li><a href="http://bit.ly/webrtcwebaudio" target="_blank" rel="external">WebRTC resources</a></li>
<li><a href="http://www.w3.org/TR/webrtc/#peer-to-peer-data-api" target="_blank" rel="external">W3C Working Draft</a></li>
<li><a href="http://tools.ietf.org/html/draft-jesup-rtcweb-data-protocol-04" target="_blank" rel="external">IETF WebRTC Data Channel Protocol Draft</a></li>
<li><a href="http://bloggeek.me/send-file-webrtc-data-api/" target="_blank" rel="external">How to send a File Using WebRTC Data API</a></li>
<li><a href="http://bloggeek.me/webrtc-data-channel-uses/" target="_blank" rel="external">7 Creative Uses of WebRTC’s Data Channel</a></li>
<li><a href="https://developer.mozilla.org/en/demos/detail/bananabread" target="_blank" rel="external">Banana Bread</a> 3D first person shooter game compiled to JS+WebGL, using WebRTC data channels in multiplayer mode</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>在两个浏览器中，为聊天、游戏、或是文件传输等需求发送信息是十分复杂的。通常情况下，我们需要建立一台服务器来转发数据，当然规模比较大的情况下，会扩展成多个数据中心。这种情况下很容易出现很高的延迟，同时难以保证数据的私密性。</p>
<p>这些问题可以通过WebRTC提供的RTCDataChannel API来解决，他能直接在点对点之间传输数据。这篇文章将介绍如何创建并使用数据通道，并提供了一些网络上常见的用例</p>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://lingyu.wang/tags/JavaScript/"/>
    
      <category term="NodeJs" scheme="http://lingyu.wang/tags/NodeJs/"/>
    
      <category term="WebIM" scheme="http://lingyu.wang/tags/WebIM/"/>
    
      <category term="WebRTC" scheme="http://lingyu.wang/tags/WebRTC/"/>
    
      <category term="WebSocket" scheme="http://lingyu.wang/tags/WebSocket/"/>
    
      <category term="即时通信" scheme="http://lingyu.wang/categories/%E5%8D%B3%E6%97%B6%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[通过JavaScript增加交互性]]></title>
    <link href="http://lingyu.wang/2014/05/21/google-adding-interactivity-with-javaScript/"/>
    <id>http://lingyu.wang/2014/05/21/google-adding-interactivity-with-javaScript/</id>
    <published>2014-05-20T16:00:00.000Z</published>
    <updated>2015-05-31T15:00:49.000Z</updated>
    <content type="html"><![CDATA[<p>JavaScript允许我们网页中的几乎所有的部分：网页内容、样式等等，它还能提供用户交互的行为。然而，JavaScript也会在页面被渲染时阻塞和延迟DOM树的构建。保证JavaScript代码的异步性，删除不必要的JavaScript代码，可以优化性能。</p>
<a id="more"></a>
<h3 id="长话短说">长话短说</h3><ul>
<li>JavaScript可以对DOM和CSSOM进行查询和修改</li>
<li>JavaScript的执行会阻塞CSSOM的构建</li>
<li>JavaScript阻塞DOM树的构建，除非显式的声明为异步</li>
</ul>
<h3 id="JavaScript造成的阻塞">JavaScript造成的阻塞</h3><p>JavaScript一个跑在浏览器中的动态语言，JavaScript允许我们修改页面中的每一方面：我们能够通过在DOM树上添加或删除节点来修改网页内容，也能修改元素的CSSOM属性，还能处理用户输入等等。这里提供了一个例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">name</span>=<span class="value">"viewport"</span> <span class="attribute">content</span>=<span class="value">"width=device-width,initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"style.css"</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Critical Path: Script<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">p</span>&gt;</span>Hello <span class="tag">&lt;<span class="title">span</span>&gt;</span>web performance<span class="tag">&lt;/<span class="title">span</span>&gt;</span> students!<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span>&gt;</span><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"awesome-photo.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span><br><span class="line">      <span class="keyword">var</span> span = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'span'</span>)[<span class="number">0</span>];</span><br><span class="line">      span.textContent = <span class="string">'interactive'</span>; <span class="comment">// change DOM text content</span></span><br><span class="line">      span.style.display = <span class="string">'inline'</span>;  <span class="comment">// change CSSOM property</span></span><br><span class="line">      <span class="comment">// create a new element, style it, and append it to the DOM</span></span><br><span class="line">      <span class="keyword">var</span> loadTime = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">      loadTime.textContent = <span class="string">'You loaded this page on: '</span> + <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">      loadTime.style.color = <span class="string">'blue'</span>;</span><br><span class="line">      <span class="built_in">document</span>.body.appendChild(loadTime);</span><br><span class="line">    </span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>JavaScript允许我们进入到DOM树中，甚至获取隐藏的span元素。事实上隐藏的元素并不存在于渲染树中，但它仍然存在于DOM树中。因此，当我们获取到它的引用时，我们能够修改其内部的文字（通过textContent进行修改），我们甚至能修改它的display样式值，从‘none’改到‘inline’。这上面说的都完成之后，我们的网页将会显示“Hello interative students!”</li>
<li>JavaScript也允许我们创建节点，为节点赋予样式，在DOM中添加和删除节点。事实上，在技术上，我们的整个页面可以通过一个巨大JavaScript文件来一个一个创建节点并给他们赋予样式。这同样能工作，但使用HTML和CSS明显更加简单。JavaScript函数的第二部分创建了一个div元素，并设定了文字，赋予了样式，然后将其添加到body上。</li>
</ul>
<p>这里，我们修改了已经存在DOM节点的的内容和CSS样式，并在文档中加入了一个全新的节点。JavaScript为我们的网页提供了更强的能力和灵活性。</p>
<p>然而，这里潜伏着一个大的性能问题。JavaScript为我们提供了更强的能力，但也为渲染的方式和时间带来的一定的限制。</p>
<p>首先，注意上面的例子中，我们的内联脚本放在了页面的底部。这是为什么呢？你可以自己试试，如果你将脚本移动到span元素的上面，可以看到script里面的脚本将会运行失败并报出错误说在文档中找不到任何span元素（<code>getElementsByTagName(&#39;span&#39;)</code>返回null）。这说明了很重要的一点：脚本运行的位置，是其在文档中的位置。当HTML解析器发现到了script标签时，他会暂停DOM的构建并将控制权交给JavaScript引擎。一旦JavaScript运行完毕，浏览器将会回到之前的位置，继续DOM的构建。</p>
<p>换句话说，脚本内部无法发现其后面的元素，因为他们还没有被处理过。或者再换个说法：<strong>运行内联脚本将阻塞DOM的构建，这也意味着阻塞页面初始的渲染</strong>。</p>
<p>页面中的脚本的另一个点在于：脚本不仅仅能够修改DOM，也能够修改CSSOM。事实上，上面的例子中，我们已经修改了span元素的display属性，将它从none修改到inline</p>
<p>那么，如果浏览器还没有完成CSSOM的下载和构建，就需要运行脚本，浏览器会怎么做？答案很简单，但效率不好：<strong>浏览器将延迟脚本的执行，直到CSSOM的下载和构建全部完成之后，才会执行。与此同时，在我们等待的时候，DOM构建也会阻塞。</strong></p>
<p>简而言之，JavaScript引入了很多的DOM、CSSOM之间的相互依赖，同时JavaScript的执行将会在浏览器处理和页面渲染时导致明显的时延：</p>
<ol>
<li>脚本在文档中的位置很重要</li>
<li>发现script标签时，会暂停DOM的构建，直到脚本被运行完成，DOM构建才会继续</li>
<li>JavaScript能够查询和修改DOM和CSSOM</li>
<li>JavaScript只有在CSSOM被构建完毕之后才会执行</li>
</ol>
<p>当我们谈及“渲染性能优化”，在很大程度上，我们谈及的是HTML、CSS和JavaScript之间的依赖关系图。</p>
<h3 id="解析器的阻塞和异步JavaScript">解析器的阻塞和异步JavaScript</h3><p>默认情况下，JavaScript的执行是“解析器阻塞”的：当浏览器在文档中遇到一个script标签时，DOM的构建会被暂停，控制权递交给JavaScript运行，DOM的构建将会在JavaScript运行完成之后继续执行。这可以从上面的内联脚本例子中看出来。事实上，内联脚本总是“解析器阻塞”的，除非特别照顾这些代码来推迟其执行。</p>
<p>那么如何通过script标签包含脚本？我们继续使用之前的的例子，将代码放在单独文件中：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">name</span>=<span class="value">"viewport"</span> <span class="attribute">content</span>=<span class="value">"width=device-width,initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"style.css"</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Critical Path: Script External<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">p</span>&gt;</span>Hello <span class="tag">&lt;<span class="title">span</span>&gt;</span>web performance<span class="tag">&lt;/<span class="title">span</span>&gt;</span> students!<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span>&gt;</span><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"awesome-photo.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"app.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> span = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'span'</span>)[<span class="number">0</span>];</span><br><span class="line">span.textContent = <span class="string">'interactive'</span>; <span class="comment">// 改变DOM中的文本</span></span><br><span class="line">span.style.display = <span class="string">'inline'</span>;  <span class="comment">// 改变CSSOM属性</span></span><br><span class="line"><span class="comment">// 创建一个新元素，为其添加样式，并将其加入到DOM中</span></span><br><span class="line"><span class="keyword">var</span> loadTime = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">loadTime.textContent = <span class="string">'You loaded this page on: '</span> + <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">loadTime.style.color = <span class="string">'blue'</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(loadTime);</span><br></pre></td></tr></table></figure>
<p>你是否认为通过<code>&lt;scirpt&gt;</code>引入的JavaScript代码和内联JavaScrip它的执行顺序不同？当然，这个答案是否定的，这两者的处理方式几样。无论是前者还是后者，浏览器都在处理后面的文档之前，暂停并执行脚本。<strong>然而：在当浏览器使用外部JavaScript文件时，也不得不暂停并等待脚本从磁盘、缓存、或陈远程服务器中获取。这可能在为页面渲染带来上千万毫秒的时延</strong></p>
<p>有一个好戏，我们确实有一个解决方法。默认情况下，所有的JavaScript都是“解析器阻塞”的，浏览器也不知道JavaScript脚本究竟会在网页山做些什么，因此它会假定最坏的情况并阻塞解析器。然而，如果我们有办法告诉浏览器我们的脚本不需要在它所处的文档位置上被执行，那会怎样呢？如果这样做，浏览器会继续DOM构建，并直到DOM构建完成后，运行脚本，无论是文件是从高速缓存直接中获取还是从远程服务器中获取。</p>
<p>那么我们怎样实现呢，我们能直接标记脚本为异步脚本：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">name</span>=<span class="value">"viewport"</span> <span class="attribute">content</span>=<span class="value">"width=device-width,initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"style.css"</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Critical Path: Script Async<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">p</span>&gt;</span>Hello <span class="tag">&lt;<span class="title">span</span>&gt;</span>web performance<span class="tag">&lt;/<span class="title">span</span>&gt;</span> students!<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span>&gt;</span><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"awesome-photo.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"app.js"</span> <span class="attribute">async</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>增加了async属性能够高速浏览器，它不会在下载和执行过程中阻塞DOM构建。这是一个巨大的效率提升！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>JavaScript允许我们网页中的几乎所有的部分：网页内容、样式等等，它还能提供用户交互的行为。然而，JavaScript也会在页面被渲染时阻塞和延迟DOM树的构建。保证JavaScript代码的异步性，删除不必要的JavaScript代码，可以优化性能。</p>]]>
    
    </summary>
    
      <category term="CSS" scheme="http://lingyu.wang/tags/CSS/"/>
    
      <category term="HTML" scheme="http://lingyu.wang/tags/HTML/"/>
    
      <category term="翻译" scheme="http://lingyu.wang/categories/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CSS的渲染阻塞]]></title>
    <link href="http://lingyu.wang/2014/05/21/google-render-blocking-css/"/>
    <id>http://lingyu.wang/2014/05/21/google-render-blocking-css/</id>
    <published>2014-05-20T16:00:00.000Z</published>
    <updated>2015-05-31T15:00:49.000Z</updated>
    <content type="html"><![CDATA[<p>默认情况下，CSS会被看做是渲染阻塞资源，也就是说，浏览器在CSSOM建立前，已经处理过的网页内容不会被显示到页面上。所以，保证你的CSS代码能够快速从服务器获取且尽可能的简短，并注意使用媒体类型（media types）和媒体查询（media queries）去进行非阻塞的渲染。</p>
<a id="more"></a>
<p>在之前的章节中，我们已经知道了要建立渲染树，必须先建立好DOM树和CSSOM树，这里有一个很重要的性能要点：HTML和CSS都是渲染阻塞资源。HTML很明显，因为如果没有创建好DOM树，浏览器都不知道有什么东西需要渲染。但CSS就不那么明显了。如果我们尝试不使用CSS的阻塞渲染去渲染一个典型的页面，会发生什么呢？</p>
<h3 id="长话短说">长话短说</h3><ul>
<li>默认情况下CSS是渲染阻塞资源</li>
<li>媒体类型和媒体查询可以让一些CSS变成非渲染阻塞资源</li>
<li>所有CSS资源，无论是阻塞还是非阻塞，都需要通过浏览器进行下载</li>
</ul>
<h3 id="CSS是渲染阻塞资源">CSS是渲染阻塞资源</h3><p>浏览器将会阻塞渲染直到DOM树和CSSOM树都创建完毕</p>
<p><strong>CSS是渲染阻塞元素，尽可能快速的让浏览器下载到文件，这样可以减少阻塞的时间</strong></p>
<p>然而，如果我们有一些只有在特定条件下才使用的样式，比如打印或是在大的显示器中显示等情况，我们当然不希望这些特定条件下才会使用的样式阻塞渲染。</p>
<h3 id="媒体类型和媒体查询">媒体类型和媒体查询</h3><p>CSS中的媒体类型和媒体查询就可以达到这种效果：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"style.css"</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"print.css"</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">media</span>=<span class="value">"print"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"other.css"</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">media</span>=<span class="value">"(min-width: 40em)"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>一个媒体查询可以由一个媒体类型和查询表达式构成，查询表达式可以是任意个数，他们检测了当前设备的特点。比如，在第一个样式表申明中并没有使用媒体类型和媒体查询，因此它在所有情况下都会被应用，也就是说，它总汇总阿红才呢过渲染阻塞。而另一方面，第二个样式表仅仅在网页内容被打印时才会被应用，可能你需要在打印时改换一下布局，改变一下字体等等，因此，这个样式表不会再页面首次加载时造成渲染阻塞。而最后一个样式表提供了一个媒体查询，浏览器将判断条件是否满足。如果浏览器满足媒体查询中的条件，浏览器将在下载并处理完这个样式表之前阻塞渲染。</p>
<p>通过使用媒体查询，我们可以根据特定的用例来定制展现的样式，比如显示和打印。同时，还能动态的判断诸如屏幕方向，缩放事件等等。在申明样式表时，重点关注媒体类型和媒体查询，他们将很大程度影响网页渲染的效率。</p>
<p>让我们考虑如下例子：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"style.css"</span>    <span class="attribute">rel</span>=<span class="value">"stylesheet"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"style.css"</span>    <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">media</span>=<span class="value">"screen"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"portrait.css"</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">media</span>=<span class="value">"orientation:portrait"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"print.css"</span>    <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">media</span>=<span class="value">"print"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>第一个样式申明将会造成渲染阻塞，它在任意情况下都会被应用；</li>
<li>第二个样式申明也会造成渲染阻塞：“screen”是默认类型，除非你执行了一个其他类型，否则浏览器总是显示的设定媒体类型为“screen”。因此这个样式申明和第一个样式申明等价；</li>
<li>第三个样式申明是一个动态的媒体查询，他会在页面加载完成之后进行计算。根据页面加载完成后的设备横竖屏来决定样式是否会阻塞渲染；</li>
<li>最后一个样式申明仅仅在页面被打印的时候起作用，因此他不会在页面首次加载进浏览器中时造成渲染阻塞</li>
</ol>
<h3 id="浏览器下载">浏览器下载</h3><p>最后，注意一下渲染阻塞只是指浏览器是否要在页面初始渲染时，是否需要渲染该资源内部的样式。无论在何种情况下，尽管非阻塞资源的优先级较低，CSS文件依旧必须要由浏览器进行下载。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>默认情况下，CSS会被看做是渲染阻塞资源，也就是说，浏览器在CSSOM建立前，已经处理过的网页内容不会被显示到页面上。所以，保证你的CSS代码能够快速从服务器获取且尽可能的简短，并注意使用媒体类型（media types）和媒体查询（media queries）去进行非阻塞的渲染。</p>]]>
    
    </summary>
    
      <category term="CSS" scheme="http://lingyu.wang/tags/CSS/"/>
    
      <category term="HTML" scheme="http://lingyu.wang/tags/HTML/"/>
    
      <category term="翻译" scheme="http://lingyu.wang/categories/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用导航计时监测渲染关键路径]]></title>
    <link href="http://lingyu.wang/2014/05/21/google-measuring-the-critical-rendering-path-with-navigation-timing/"/>
    <id>http://lingyu.wang/2014/05/21/google-measuring-the-critical-rendering-path-with-navigation-timing/</id>
    <published>2014-05-20T16:00:00.000Z</published>
    <updated>2015-05-31T15:00:49.000Z</updated>
    <content type="html"><![CDATA[<p>没办法监测，就没办法优化。幸运的是，浏览器提供了一系列用来监测渲染关键路径上每一步的接口，叫导航计时接口（Navigation Timing API）<br><a id="more"></a></p>
<h3 id="长话短说">长话短说</h3><ul>
<li>导航计时为监测渲染关键路径提供了高分辨率的时间戳</li>
<li>浏览器在到达渲染关键路径的不同阶段时，会触发一系列的事件</li>
</ul>
<h3 id="用于监测的时间戳">用于监测的时间戳</h3><p>好的性能策略都是建立在良好的测量基础之上的。下面这张图说明了导航计时接口提供的API：</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-21/1.png" alt="导航计时接口提供的API"></p>
<p>上面的每一个标签都提供了一个方法，用于检测每一个页面加载的高分辨率的时间戳。在这里，我们仅仅介绍除了与网络相关的时间戳的哪些一部分时间戳，剩下的我们会在以后的章节作介绍</p>
<p>那么，这些时间戳代表着什么？</p>
<ul>
<li>domLoading：整个处理过程开始的时间，也就是浏览器开始解析HTML文档的第一个字节的时间</li>
<li>domInteractive：浏览器解析完所有HTML，并完成DOM构建的时间</li>
<li>domContentLoaded：开始构建渲染树的时间点，就是DOM构建完毕后，若没有样式以及阻塞的JavaScript运行的时间点<ul>
<li>许多JavaScript框架都会监听这个事件，然后执行他们自己的逻辑。因此浏览器提供了EventStart和EventEnd两个时间戳来允许我们知道具体运行消耗的时间</li>
</ul>
</li>
<li>domComplete：和名字一样，记录了页面上的所有资源都下载完成（包括图片）以及所有处理逻辑都结束后的时间点。这个时间点过后，浏览器旋转的加载标记将不再旋转了</li>
<li>loadEvent：最后，浏览器触发onload事件来执行一些其他的应用逻辑</li>
</ul>
<h3 id="里程碑">里程碑</h3><p>根据HTML的规范，浏览器会检测所有事件：什么时候应该触发事件，应该满足哪些条件等等。对于我们来说，我们只需要关注渲染关键路径上的一些“里程碑”事件：</p>
<ul>
<li>domIneractive：说明DOM构建完毕</li>
<li>domContentLoaded：当DOM和CSSOM都完成后触发<ul>
<li>如果没有“解析器阻塞”的JavaScript代码，documentContentLoaded将直接在domInteractive之后触发</li>
</ul>
</li>
<li>domComplete：当页面及其所有资源全部完毕时触发</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Critical Path: Measure<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">name</span>=<span class="value">"viewport"</span> <span class="attribute">content</span>=<span class="value">"width=device-width,initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">link</span> <span class="attribute">href</span>=<span class="value">"style.css"</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">measureCRP</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> t = <span class="built_in">window</span>.performance.timing,</span><br><span class="line">          interactive = t.domInteractive - t.domLoading,</span><br><span class="line">          dcl = t.domContentLoadedEventStart - t.domLoading,</span><br><span class="line">          complete = t.domComplete - t.domLoading;</span><br><span class="line">        <span class="keyword">var</span> stats = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);</span><br><span class="line">        stats.textContent = <span class="string">'interactive: '</span> + interactive + <span class="string">'ms, '</span> +</span><br><span class="line">            <span class="string">'dcl: '</span> + dcl + <span class="string">'ms, complete: '</span> + complete + <span class="string">'ms'</span>;</span><br><span class="line">        <span class="built_in">document</span>.body.appendChild(stats);</span><br><span class="line">      &#125;</span><br><span class="line">    </span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span> <span class="attribute">onload</span>=<span class="value">"measureCRP()"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">p</span>&gt;</span>Hello <span class="tag">&lt;<span class="title">span</span>&gt;</span>web performance<span class="tag">&lt;/<span class="title">span</span>&gt;</span> students!<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span>&gt;</span><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"awesome-photo.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的例子乍看之下可能比较吓人，但实际上非常简单，导航计时API捕获了相关的时间戳，而我们的JavaScript代码放在onload事件的回调函数中，只有触发了onload事件，才会执行。onload事件只有在domInteractive、domContentLoaded和domComplete事件都完成之后才会触发，所以我们可以捕获到这些时间戳之间的差值，算出每个阶段所耗费的时间</p>
<p><img src="http://skyinlayerblog.qiniudn.com/blog/img/2014-5-21/2.png" alt="时间戳检测结果"></p>
<p>综上所述，我们可以获得一些“里程碑事件”以及一些简单的函数来输出测量结果。当然我们可以不将这些数据输出到页面上，而是发送这些分析的数据到专门的分析服务器（Google的分析工具就会自动做这些事），这样就能很方便的检测网页的性能，确定候选页面，并尝到优化所带来的甜头。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>没办法监测，就没办法优化。幸运的是，浏览器提供了一系列用来监测渲染关键路径上每一步的接口，叫导航计时接口（Navigation Timing API）<br>]]>
    
    </summary>
    
      <category term="CSS" scheme="http://lingyu.wang/tags/CSS/"/>
    
      <category term="HTML" scheme="http://lingyu.wang/tags/HTML/"/>
    
      <category term="翻译" scheme="http://lingyu.wang/categories/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
</feed>