layout: art
title: 前端测试
subtitle: 前端自动化测试
categories:
- 前端综合
tags:
- JavaScript
- 测试
- NodeJs
date: 2015/2/29
---

之前曾经在[2015年总结](http://lingyu.wang/#/post/2016/2/16/2015)中提到一些测试相关的内容，这次在这里专门写一篇文章整理一下这段时间作为一个测试工程师学到的点点滴滴。

<!-- more -->

## 前言

### 测试好处都有啥

学生时代一直不喜欢写测试，主要是觉得编写和维护测试用例非常的浪费时间。在真正写了一段时间的基础组件和基础工具后，我才发现自动化测试有很多好处。

测试最重要的自然是提升代码质量。代码有测试用例，虽不能说百分百无bug，但至少说明测试用例覆盖到的场景是没有问题的。有测试用例，发布前跑一下，可以杜绝各种脑残引起的功能bug，比如改了A处影响了B处的功能。

自动化测试另外一个重要特点就是快速反馈，反馈越迅速意味着开发效率越高。拿UI组件为例，开发过程都是打开浏览器刷新页面点点点才能确定是不是真的是自己想要的效果。接入自动化测试以后，通过脚本代替这些手动点击，接入代码watch后每次保存文件都能快速得知自己的改动是否对主流程造成影响，节省了很多时间，毕竟机器干事情比人总是要快得多。

有了自动化测试，开发者会更加信任自己的代码。开发者将不会惧怕将代码交给别人维护，不用担心别的开发者在代码里搞“破坏”。后人接手一段有测试用例的代码，修改起来也会更加从容。测试用例里非常清楚的阐释了开发者和使用者对于这端代码的期望和要求。

### 考虑投入产出比

说了这么多测试的好处，并不代表一上来就要写出100%场景覆盖的测试用例。个人一直坚持一个观点：**基于投入产出比来做测试**。由于维护测试用例也是一大笔开销（毕竟没有多少测试会专门帮前端写业务测试用例，而前端使用的流程自动化工具更是没有测试参与了）。对于像基础组件啊，基础模型啊之类的不常变更且复用较多的部分，可以考虑去写测试用例来保证质量。个人比较倾向于先写少量的测试用例覆盖到80%~90%的场景，保证覆盖主流程。一些极端场景出现的bug可以在迭代中形成测试沉淀，场景覆盖也将逐渐趋近100%。当达到100%场景覆盖，那就意味着只要测试通过，代码就没bug了。但对于迭代较快的业务逻辑以及生存时间不长的活动页面之类的就别花时间写测试用例了，维护测试用例的时间大了去了，不如喝杯茶冷静下让QA他们去测吧。

## Node.js模块的测试

对于Node.js的模块，测试算是比较方便的，毕竟源码都是看得见摸得着的。

### 测试工具

测试主要使用到的工具是测试框架、断言库以及代码覆盖率工具：

1. 测试框架：[mocha](https://mochajs.org/)、[Jasmine](http://jasmine.github.io/)等等，测试主要提供了清晰简明的语法来描述测试用例，以及对测试用例分组，测试框架会抓取到代码抛出的AssertionError，并增加一大堆附加信息，比如那个用例挂了，为什么挂等等。测试框架通常提供TDD（测试驱动开发）或BDD（行为驱动开发）的测试语法来编写测试用例，关于TDD和BDD的对比可以看一篇比较知名的文章[The Difference Between TDD and BDD](http://joshldavis.com/2013/05/27/difference-between-tdd-and-bdd/)。不同的测试框架支持不同的测试语法，比如mocha既支持TDD也支持BDD，而Jasmine只支持BDD。这里后续以mocha的BDD语法为例
2. 断言库：[should.js](https://shouldjs.github.io/)、[chai](http://chaijs.com/)、[expect.js](https://github.com/Automattic/expect.js)等等，断言库提供了很多语义化的方法来对值做各种各样的判断。当然也可以不用断言库，Node.js中也可以直接使用[原生asset库](https://nodejs.org/api/assert.html)。这里后续以should.js为例
3. 代码覆盖率：[istanbul](https://github.com/gotwarlost/istanbul)等等为代码在语法级分支上打点，检测测试用例运行后到底有多少代码跑了，多少代码没有跑。

### 一个简单的测试项目
